<<<<<<< HEAD
[{"content":"看了官方文档的stream介绍和网上的博客，总结redis中stream的用法。官网链接\n介绍 redis在5.0之后的版本里多出了一个新的数据结构stream，在系统已经使用了redis，并且并发量不是很大的情况下，就可以使用stream作为消息队列使用，不用去专门引入新的消息中间件。\n基本概念如下：\n消费组：每个消费组都是独立的，同一个消费组里面可以有多个消费者，这些消费者都是竞争关系，一个消息被消费者A消费了，消费游标last_delivered_id都会后移一个位置。\n消费者：消费者有自己的唯一id，同时内部维护了一个pending队列，消费后的消息都会在其中保存id，只有当ack之后才会从pending中移除。这个队列就可以用来解决，如果客户端挂了，下次重启服务的时候仍然可以处理这条消息。\n消息队列：也就是stream，和其他数据结构不一样，当list为空时，redis会自动删除这个list，stream可以为空然后保留下来，是因为消息队列里面有消费组和消费者的信息。\n消息：每个消息都有一个id，也就是时间戳，例如1698731874660-0，前面是时间戳，后面0表示在这个毫秒内的第几个。这样记录id就可以实现范围查找。\n基本命令 xadd 追加消息 xdel 删除消息。删除标志位 xrange 获取制定的消息 xlen 消息长度\n1 2 3 4 5 6 XADD race:italy * rider Castilla XADD race:france * rider Castilla speed 30.2 position 1 location_id 1 race:italy stream名称 * id，可以自己设置，一般都用这个，让redis自动生成 rider Castilla 消息内容，为一个一个的k-v 1 2 3 4 5 6 7 xrange race:italy - + - 代表最小 + 代表最大 也可以使用具体的id号，获取单条消息，可以start和end使用同一个id 比如：xrange race:italy 1698732650059-0 1698732650059-0 这些id其实就是时间，我们也可以制定不存在的时间比如1698732650060-0，把后面的59改成60 xrange race:italy 1698732650060-0 + 1 2 xlen race:italy xdel 1698732650059-0 ，这个命令跟上消息id就可以了 单消费者 可以不使用消费组，就使用单个消费者来进行消费，命令是xread xread count 10 streams race:italy 0-0 从头开始消费，消费10个 还可以制定阻塞的方式来消费 xread block 0 streams race:italy $ 从最新的消息开始消费，block后面接上阻塞时间，0代表一直阻塞，我们在另一个客户端添加上信息，这边就可以消费到了。\n如果是单个消费者这样的话，就需要记录当前的消费位置，然后继续消费位置继续向下消费就可以了，也可以消费完了直接删除也行。\n消费组 因为我之前在redis里面创建了消费组，现在直接先把测试数据清空（生产环境不要这样做）。也可以使用xgroup DESTROY去删除。\n1 FLUSHDB 插入测试数据\n1 2 3 4 5 XADD race:italy * rider Castilla XADD race:italy * rider Royce XADD race:italy * rider Sam-Bodden XADD race:italy * rider Prickett XADD race:italy * rider Norem 创建消费组\n1 2 XGROUP CREATE race:italy italy_riders 0-0 0-0表示从头开始消费，使用$表示只消费新的数据 消费数据\n1 2 3 4 5 6 7 XREADGROUP GROUP italy_riders Alice COUNT 1 STREAMS race:italy \u0026gt; italy_riders 组名 Alice 消费者名，需要唯一 race:italy stream名 \u0026gt; 从last-delivered-id开始消费，当前就是0-0，如果消费了一条信息，就是第二条消息的id，在消息都被消费之后就是新的消息 也可以加上block来变成阻塞的方法 再执行一次 XREADGROUP GROUP italy_riders Alice COUNT 1 STREAMS race:italy \u0026gt; ，就是第二条消息 这时候对于这个消费组来说已经消费了2条消息，此时，消费组中的另一个消费者来消费，也只会消费到第三条消息 XREADGROUP GROUP italy_riders Bob COUNT 1 STREAMS race:italy \u0026gt; 我这显示第4条消息，是因为我之前执行了一次上面的命令\n这样同一个消费组就可以做负载均衡了，对于一堆消息，有多个客户端来消费，每个客户端相互独立，消息也只会被一个客户端消费。\n确认数据\n消费完数据之后，需要ack，这样才会在每个消费者的pending中移除该次消息。\n查看当前消费情况 xinfo stream race:italy\nlength 当前有5条数据 groups 一个消费组 last-generated-id 最后一条消息id first-entry和last-entry 第一条消息和最后一条消息\n查看消费组情况 xinfo groups race:italy\nname 组名 consumers 消费者个数 pending 未ack的消息数 last-delivered-id 最后一条消费消息id\n查看消费者情况 xinfo consumers race:italy italy_riders\nname 消费者名 pending 未ack的消息个数\n使用ack命令确认数据 xack race:italy italy_riders 1698738784018-0\n查看pending队列\nXPENDING race:italy italy_riders - + 10\n里面显示了每个未ack的消息的情况，其中第四个字段表示被消费的次数，如果Alice再一次消费，并且未ack的话，这个值就会加1\n在客户端消费者读取 Stream 消息时，Redis 服务器将消息回复给客户端的过程中，客户端突然断开了连接，消息就丢失了。但是 PEL 里已经保存了发出去的消息 ID。待客户端重新连上之后，可以再次收到 PEL 中的消息 ID 列表。不过此时 xreadgroup 的起始消息 ID 不能为参数\u0026gt;，而必须是任意有效的消息 ID，一般将参数设为 0-0，表示读取所有的 PEL 消息以及自last_delivered_id之后的新消息。\n","date":"2023-10-31T21:00:04+08:00","permalink":"https://ichigo-xin.github.io/p/redis%E4%B8%ADstream%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"redis中stream的使用"},{"content":"Algorithm 125. 验证回文串\n用双指针解决，首末两个指针同时向中间逼近\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution: def isPalindrome(self, s: str) -\u0026gt; bool: s = \u0026#39;\u0026#39;.join(filter(str.isalnum, s.lower())) if len(s) \u0026lt;= 1: return True left = 0 right = len(s) - 1 while left \u0026lt; right: if s[left] != s[right]: return False left += 1 right -= 1 return True 看他人的题解中有两行的写法\n1 2 3 4 class Solution: def isPalindrome(self, s: str) -\u0026gt; bool: s = \u0026#39;\u0026#39;.join(filter(str.isalnum, s.lower())) return s == s[::-1] Review Understanding Multiprocessing and Multithreading in Python | HackerNoon\n这篇文章介绍了python里面的多线程和多进程。\npython里的多线程也是有共享内存的，但是和Java不同的是由于GIL的存在，其实python里的多线程是加了全局锁的，只会在一个cpu上运行，其实不是真正的并行执行。\npython里的多进程，就是操作系统多个进程同时执行。\nTips 记录一下最近用到的git操作\n1.rebase的时候解决冲突，把自己的代码给删除了。在idea的控制台上看提交历史也没有需要的代码。\n解决方法：\ngit reflog.找到rebase之前的提交的hash值，确定丢失的代码在哪个提交里\n使用git cherry-pick （hash值）,引入提交\n解决冲突\nShare 第164期 | 你工作开心吗？ (geekbang.org) 这是以前看到的一篇文章，讲的职业倦怠。\n总结来说，职业倦怠是不可避免，但是我们采取措施措施，做出改变。之前也看过一篇文章说，职业倦怠也是周期性的，就像脉冲一下，过一阵子又有了。\n在我看来做到工作和生活平衡，然后给自己充电，有时候做些稍微有些挑战性的工作，就可以减少个人倦怠的情绪。\n","date":"2023-09-14T19:04:17+08:00","permalink":"https://ichigo-xin.github.io/p/arts-week4/","title":"ARTS Week4"},{"content":"Algorithm 旋转链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution: def rotateRight(self, head: Optional[ListNode], k: int) -\u0026gt; Optional[ListNode]: if k == 0 or not head or not head.next: return head n = 1 cur = head while cur.next: n += 1 cur = cur.next if (add := n - k % n) == n: return head cur.next = head while add: cur = cur.next add -= 1 res = cur.next cur.next = None return res Review pa中使用lombok可能会导致的问题\n1.@Data或者是@EqualsAndHashCode注解，一般情况下主键id都是由数据库自动生成的，这时候即使其他属性值相同的对象的hash值也是不相同的\n2.@ToString,在有多对多的关系中，如果没有设置懒加载，直接打印的话，就会出现a引用b，b引用a，这样无线循环，栈溢出，最好使用exclude\n3.就是不要忘记添加无参构造函数\nTips 1.py2neo中rel = self.repository.graph.match((record.node, handler.node,), r_type=\u0026ldquo;be_handled\u0026rdquo;).first()方法中，如果这个rel是没有任何属性值的，那结果就是None\n2.使用jpa的findall方法报错数组越界，发现是实体类里面有个枚举字段，里面还没有定义任何枚举值。\nShare 最近看到一篇大数据杀熟文章的分析，同一个商品，商家和平台根据用户数据找出不同客户的最高承受价格，这就是大数据杀熟。从用户的角度来说，只有随着个人隐私的数据的保护才能避免被杀熟，现阶段还是无法避免的。\n","date":"2023-08-29T18:04:17+08:00","permalink":"https://ichigo-xin.github.io/p/arts-week3/","title":"ARTS Week3"},{"content":"Algorithm 这周继续回溯算法，题目是n皇后\n解析:直接用一个数组来表示放置位置，例如[1,3,0,2]表示第一行放1的位置，第二行放3的职位\u0026hellip;，path表示路径，进入前先判断是否合法，dfs之前将当前节点加入path，dfs之后做反操作，状态重置。然后就是判断是否合法，同一列就是值在集合里面，斜着的话打个比方,目前path是[1.3],现在第三行加入2，|2-3|=|2的下标-3的下标|\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution: def solveNQueens(self, n: int) -\u0026gt; list[list[str]]: path = [] result = [] self.dfs(0, n, path, result) return result def dfs(self, index, n, path, result): if index == n: result.append(self.trans(path, n)) for i in range(n): if not self.is_valid(i, path): continue path.append(i) self.dfs(index + 1, n, path, result) path.pop() def is_valid(self, num, path): for i in range(len(path)): if num in path: return False if abs(path[i] - num) == abs(len(path) - i): return False return True def trans(self, path, n): \u0026#34;\u0026#34;\u0026#34;转换为输出结果\u0026#34;\u0026#34;\u0026#34; temp = \u0026#34;.\u0026#34; * n result = [] for item in path: result.append(temp[:item] + \u0026#34;Q\u0026#34; + temp[item+1:]) return result Review Spring Data JPA中@Joincolumn和@mappedBy的区别 结论：@Joincolumn在关系拥有端定义映射，然后这个关系的另一端使用mappedBy进行定义\n发现这个网站是Java生态相关的，主要是spring和restful，后面可以多来逛逛。\nTips 项目开发过程中可以开启feign的日志功能方便接口开发测试，配置文件中开启full级别\nShare 今天看了极客时间的学习进度，《左耳听风》专栏上的进度是67%。这个专栏我是断断续续学习的，应该是从前年开始看的，前年看了一些章节，去年也看了一些章节。感觉入这行时间不长的原因，好多章节看得懵懵懂懂，像编程范式这些章节就是这样。让我留下深刻印象的主要还是耗子叔的一些观点吧。\n查看官网资料。我学习技术也是这样做的，好的博客，官网，极客时间专栏这些我都看，我后面也会去看官方文档。我自己也写博客，主要是记录和分享，但是我还是推荐大家去官网查阅资料，所以我在博客里面都会加上官网的链接。 学习几门语言。目前主要Java开发,工作中写过半年c++（菜鸡一个），python和go都会一点吧。 扎实基本功。算法方面在leetcode做了100多道题，每道题做几遍，隔几天做一次，通过提交次数将近500次。计算机网络方面还没开始，打算后续找本书看，极客时间上也有相关专栏，最近在看spring相关的资料，等这个模块结束后就开始学习计算机网络。 ","date":"2023-08-23T17:36:11+08:00","permalink":"https://ichigo-xin.github.io/p/arts-week2/","title":"ARTS Week2"},{"content":"Algorithm 题目：全排列\n最近工作中使用python搭建一个知识图谱服务，之前都是用python写一些脚本，而且都是参考其他模块的代码，感觉都是照葫芦画瓢，趁着这个项目好好学习下python，也打算在刷算法题也用python写，强行走出舒适区。\n题目分析：全排列使用的是回溯算法，和深度优先遍历差不多。就是需要使用递归，在处理当前层进入下一层之前需要添加到状态变量里面，之后返回到当前层进入另一个选择时将刚才加入的部分进行反操作。\n回溯算法有三个关键词：状态（路径）、选择列表、结束条件 在当前状态时，for循环选择列表，然后选择一个进入，这时候就需要把选择加入到状态里面，当第一条路走完，回到这个点的时候，就需要进行状态重置，然后选择另一个进入。就这样做完所有的遍历。 参考文章\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lass Solution: def permute(self, nums: list[int]) -\u0026gt; list[list[int]]: res = [] path = [] if len(nums) == 0: return res self.dfs(nums, res, path, 0) return res def dfs(self, nums: list, res: list, path, level): if len(path) == len(nums): res.append(path.copy()) for num in nums: if num in path: continue path.append(num) self.dfs(nums, res, path, level + 1) path.pop() Review python web框架Django和FastAPI的对比 文章从性能、路由、数据库支持、模版、安全、社区支持、部署和开发这几个方面对这两个框架进行了对比\n性能：FastAPI使用的是异步框架，性能更快，Django使用的是同步框架，对流程的控制更加容易些 路由：FastAPI是针对api设计的，写路由更加方便\n数据库支持：Django内置了ORM映射框架\n模版和前端集成：Django内置了一个模版操作系统，更加容易，FastAPI则是凸显了他在API集成方面的优势，与VUE和Angular集成方便\n安全：在sql注入攻击和XSS攻击，两个框架都是做了保护的。Django有自己的权限验证系统\n社区支持：两个社区都很活跃\n部署：都有各自部署领域\n开发：FastAPI开发更快\nTips py2neo中，如果使用cypher语句先match节点，然后再创建节点关系的方式的话，就会创建重复关系，直接使用Relationship就不会创建重复关系。尽量使用这种方式，如果使用cypher语句的话先要判断关系是否存在。\n1 2 3 4 5 6 7 8 9 10 event = self.repository.graph.nodes.match( \u0026#34;Event\u0026#34;, event_id=event_po.event_id ).first() record = self.repository.graph.nodes.match( \u0026#34;Record\u0026#34;, record_id=event_po.record_id ).first() if record is None or event is None: continue rel = Relationship(record, \u0026#34;has_event\u0026#34;, event) self.repository.graph.create(rel) Share 做一件事之前做一定的准备是有必要的。但是一直停留在想的阶段，只会造成内耗，最重要的还是行动起来。在做这件事的过程中自然而然会出现许多问题，一个一个解决就可以了。行动起来最重要！\n","date":"2023-08-16T23:35:48+08:00","permalink":"https://ichigo-xin.github.io/p/arts-week1/","title":"ARTS Week1"},{"content":"在本篇文章中，我将手写模拟Spring整合Jpa流程。\n项目搭建 项目依赖:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.data\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.28\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-entitymanager\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.4.32.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.22\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 连接池 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring test --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.13\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.data\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-data-bom\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2020.0.14\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package com.xin.config; import com.alibaba.druid.pool.DruidDataSource; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.data.jpa.repository.config.EnableJpaRepositories; import org.springframework.orm.jpa.JpaTransactionManager; import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean; import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter; import org.springframework.transaction.PlatformTransactionManager; import org.springframework.transaction.annotation.EnableTransactionManagement; import javax.sql.DataSource; /** * @author : ichigo-xin * @date 2023/7/18 */ @Configuration @EnableJpaRepositories(basePackages = \u0026#34;com.xin.repository\u0026#34;) @EnableTransactionManagement @ComponentScan(\u0026#34;com.xin\u0026#34;) public class SpringDataConfig { @Bean public DataSource druidDataSource(){ DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setDriverClassName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); druidDataSource.setUrl(\u0026#34;jdbc:mysql://localhost:3306/springdata?serverTimezone=UTC\u0026#34;); druidDataSource.setUsername(\u0026#34;root\u0026#34;); druidDataSource.setPassword(\u0026#34;123456\u0026#34;); return druidDataSource; } @Bean public LocalContainerEntityManagerFactoryBean entityManagerFactory(){ HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter(); adapter.setGenerateDdl(true); adapter.setShowSql(true); LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean(); factory.setDataSource(druidDataSource()); factory.setPackagesToScan(\u0026#34;com.xin.pojo\u0026#34;); factory.setJpaVendorAdapter(adapter); return factory; } @Bean public PlatformTransactionManager transactionManager(){ JpaTransactionManager txManager = new JpaTransactionManager(); txManager.setEntityManagerFactory(entityManagerFactory().getObject()); return txManager; } } pojo类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Entity @Table(name = \u0026#34;tb_customer\u0026#34;) @Getter @Setter @ToString @AllArgsConstructor @NoArgsConstructor public class Customer { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \u0026#34;cust_id\u0026#34;) private Long custId; @Column(name = \u0026#34;cust_name\u0026#34;) private String custName; @Column(name = \u0026#34;cust_address\u0026#34;) private String custAddress; } CustomerRepository:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package com.xin.repository; import com.xin.pojo.Customer; import org.springframework.data.repository.PagingAndSortingRepository; import org.springframework.stereotype.Component; /** * @author: ichigo-xin * @create: 2023-07-18 00:47 * @description: **/ //@Component public interface CustomerRepository extends PagingAndSortingRepository\u0026lt;Customer, Long\u0026gt; { } application:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.xin; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import com.xin.config.SpringDataConfig; import com.xin.pojo.Customer; import com.xin.repository.CustomerRepository; /** * @author: ichigo-xin * @create: 2023-07-26 01:24 * @description: **/ public class Application { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringDataConfig.class); CustomerRepository repository = context.getBean(CustomerRepository.class); Customer customer = repository.findById(1L).get(); System.out.println(customer); } } 手写模拟Spring Data Jpa 在配置类中使用@EnableJpaRepositories(basePackages = \u0026ldquo;com.xin.repository\u0026rdquo;)注解，就是开启spring data jpa，现在是可以查询出数据的。\n我们把这个注解注释掉，此时运行报错：\nNo qualifying bean of type \u0026lsquo;com.xin.repository.CustomerRepository\u0026rsquo; available\n说明没有这个类型的bean，这时候我们就需要去找这个bean没有注入的原因。\n问题原因 spring读取注册BeanDefinition的流程如下：需要创建BeanDefinition，再根据BeanDefinition创建对象（bean的创建就不继续了），我们在这几个类里面打上断点，调试看看。\n在这两个红框的方法内，一个是判断类上面有没有@component注解，另一个是判断这个类是不是接口等\n可以看到如果是一个接口，他就不会注册成beandefinition。\n自定义扫描器将接口也注册成beandefinition 我们自定义扫描器，不排除掉接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package com.xin.my; import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.beans.factory.config.BeanDefinitionHolder; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.context.annotation.ClassPathBeanDefinitionScanner; import org.springframework.context.annotation.ScannedGenericBeanDefinition; import org.springframework.core.type.AnnotationMetadata; import org.springframework.core.type.classreading.MetadataReader; import java.io.IOException; import java.util.Set; /** * @author: ichigo-xin * @create: 2023-07-26 02:19 * @description: **/ public class MyJpaClassPathBeanDefinitionScanner extends ClassPathBeanDefinitionScanner { public MyJpaClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry) { super(registry); } @Override protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) { AnnotationMetadata metadata = beanDefinition.getMetadata(); return metadata.isInterface(); } } 再运行代码，就会报错：\nCaused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.xin.repository.CustomerRepository]: Specified class is an interface\n这说明CustomerRepository作为接口也注册成一个beandefinition了。只是不能进行实例化。在spring当中，每一个bean其实就是一个实例化的对象，那么接口肯定不能实例化的，这里我们就需要使用动态代理了。\n自定义MyJpaProxy，实现JpaRepository接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package com.xin.my; import org.springframework.data.domain.Example; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.domain.Sort; import org.springframework.data.jpa.repository.JpaRepository; import javax.persistence.EntityManager; import java.util.List; import java.util.Optional; /** * @author: ichigo-xin * @create: 2023-07-26 21:08 * @description: **/ public class MyJpaProxy implements JpaRepository { EntityManager em; Class pojoClass; public MyJpaProxy(EntityManager em, Class pojoClass) { this.em = em; this.pojoClass = pojoClass; } @Override public Optional findById(Object id) { System.out.println(\u0026#34;自定义JPA统一实现\u0026#34;); return Optional.of(em.find(pojoClass, id)); } .... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.xin.my; import javax.persistence.EntityManager; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; /** * @author: ichigo-xin * @create: 2023-07-26 21:01 * @description: **/ public class MyJpaInvocationHandler implements InvocationHandler { EntityManager em; Class pojoClass; public MyJpaInvocationHandler(EntityManager em, Class pojoClass) { this.em = em; this.pojoClass = pojoClass; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { MyJpaProxy myJpaProxy = new MyJpaProxy(em, pojoClass); Method jpaMethod = myJpaProxy.getClass().getMethod(method.getName(), method.getParameterTypes()); return jpaMethod.invoke(myJpaProxy, args); } } 我们自定义MyJpaFactoryBean，在getObject方法里面使用Proxy.newProxyInstance(）来创建对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package com.xin.my; import com.xin.repository.CustomerRepository; import org.springframework.beans.factory.FactoryBean; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean; import org.springframework.stereotype.Component; import javax.persistence.EntityManager; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Proxy; import java.lang.reflect.Type; /** * @author: ichigo-xin * @create: 2023-07-26 20:56 * @description: **/ public class MyJpaFactoryBean implements FactoryBean { @Autowired LocalContainerEntityManagerFactoryBean entityManagerFactory; Class\u0026lt;?\u0026gt; repositoryInterface; public MyJpaFactoryBean(Class\u0026lt;?\u0026gt; repositoryInterface) { this.repositoryInterface = repositoryInterface; } @Override public Object getObject() throws Exception { EntityManager em = entityManagerFactory.createNativeEntityManager(null); //获取当前接口的pojo类 ParameterizedType parameterizedType = (ParameterizedType) repositoryInterface.getGenericInterfaces()[0]; Type type = parameterizedType.getActualTypeArguments()[0]; Class clazz = Class.forName(type.getTypeName()); return Proxy.newProxyInstance( CustomerRepository.class.getClassLoader(), new Class[]{repositoryInterface}, new MyJpaInvocationHandler(em, clazz)); } @Override public Class\u0026lt;?\u0026gt; getObjectType() { return repositoryInterface; } } 接下来我们需要在容器加载BeanDefinition的时候将本来应该是实例化接口的步骤，替换成我们上面自定义的实现。\n在 Spring 框架中，BeanDefinitionRegistryPostProcessor 是一个重要的扩展点接口，它允许开发者在容器加载 Bean 定义（BeanDefinition）之后，但在实例化 Bean 之前，对 Bean 定义进行自定义修改或添加新的 Bean 定义。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package com.xin.my; import org.springframework.beans.BeansException; import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor; import org.springframework.core.type.filter.AssignableTypeFilter; import org.springframework.data.repository.Repository; import org.springframework.stereotype.Component; /** * @author: ichigo-xin * @create: 2023-07-26 02:24 * @description: **/ @Component public class MyJpaBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor { @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { MyJpaClassPathBeanDefinitionScanner scanner = new MyJpaClassPathBeanDefinitionScanner(registry); scanner.addIncludeFilter(new AssignableTypeFilter(Repository.class)); scanner.scan(\u0026#34;com.xin.repository\u0026#34;); } @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { } } 同时给MyJpaClassPathBeanDefinitionScanner重写doscan方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.xin.my; import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.beans.factory.config.BeanDefinitionHolder; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.context.annotation.ClassPathBeanDefinitionScanner; import org.springframework.context.annotation.ScannedGenericBeanDefinition; import org.springframework.core.type.AnnotationMetadata; import org.springframework.core.type.classreading.MetadataReader; import java.io.IOException; import java.util.Set; /** * @author: ichigo-xin * @create: 2023-07-26 02:19 * @description: **/ public class MyJpaClassPathBeanDefinitionScanner extends ClassPathBeanDefinitionScanner { public MyJpaClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry) { super(registry); } @Override protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) { AnnotationMetadata metadata = beanDefinition.getMetadata(); return metadata.isInterface(); } @Override protected Set\u0026lt;BeanDefinitionHolder\u0026gt; doScan(String... basePackages) { Set\u0026lt;BeanDefinitionHolder\u0026gt; beanDefinitionHolders = super.doScan(basePackages); for (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) { ScannedGenericBeanDefinition beanDefinition = (ScannedGenericBeanDefinition) beanDefinitionHolder.getBeanDefinition(); String beanClassName = beanDefinition.getBeanClassName(); beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // 修改beanDefinition beanDefinition.setBeanClass(MyJpaFactoryBean.class); } return beanDefinitionHolders; } } 我们在doscan方法中对beanDefinition的BeanClass进行替换。\n运行代码，成功查询出来数据了。 同时我们也可以看下代理对象\n","date":"2023-07-26T21:56:50+08:00","permalink":"https://ichigo-xin.github.io/p/%E6%89%8B%E5%86%99spring%E6%95%B4%E5%90%88jpa%E6%B5%81%E7%A8%8B/","title":"手写Spring整合Jpa流程"},{"content":"在本篇文章中，我会对知识图谱进行介绍，并且会演示如何搭建一个知识图谱，这样你也可以跟着这篇博客搭建知识图谱。本文是全系列中的第3/3篇\nNeo4j和知识图谱：Neo4j安装和使用\nNeo4j和知识图谱：Neo4j内置算法库的安装和使用\nNeo4j和知识图谱：使用Neo4j构建知识图谱\n知识图谱介绍 知识图谱是一种语义化的知识表示形式，它可以将实体、属性和实体之间的关系以图谱的形式呈现出来。知识图谱可以用于自然语言理解、信息检索、智能推荐等领域，是人工智能技术的重要组成部分。\n在知识图谱中，实体通常指现实世界中的事物，如人、地点、组织等，而属性则是实体的特征或属性，如人的年龄、地点的经纬度等。实体之间的关系可以分为不同类型，如属于、工作于、是朋友等。通过建立知识图谱，可以将这些实体和关系以结构化的方式进行表达，从而更好地理解和利用这些知识。\n总之，知识图谱是一种强大的工具，可以帮助我们更好地理解和利用现实世界中的知识，从而实现更智能化的应用和服务。\n知识图谱的构建流程 构建一个知识图谱需要经过以下步骤：\n知识抽取 知识抽取是指从非结构化数据中提取出实体、属性和实体间的关系的过程。这一步通常需要使用自然语言处理技术，如实体识别、关系抽取等。\n知识表示 知识表示是将抽取出的知识以一定的格式进行表示的过程。常用的表示方式有三元组和RDF等。\n知识存储 知识存储是将知识表示存储到数据库中的过程。常用的数据库有图数据库、关系型数据库和文档数据库等。\n知识推理 知识推理是指根据已有的知识推导出新的知识的过程。这一步通常需要使用逻辑推理、规则推理等技术。\n知识应用 知识应用是指将知识图谱应用到具体的应用场景中的过程。如搜索引擎、智能问答、智能客服等。\n知识图谱的搭建大致就是这几个流程，在一个知识图谱项目中，不一定每个步骤都有。比如我接下来的例子中，数据已经以结构化的形式存在数据库中了，不需要做知识抽取的过程，同时知识表示其实就是构建模型的过程。\n搭建一个演员电影知识图谱 项目使用 python + py2neo + neo4j + mysql 进行搭建，项目代码\n1.数据来源于从零开始构建影视类知识图谱（一）半结构化数据的获取 - 知乎 (zhihu.com),在我的github项目里面也有。\n2.数据建模，这里就借用了结构化数据到RDF文件的概念，table对应class，一条记录对应一个实体，记录中的字段对应属性。简化一点，那我们在neo4j数据库中就只有两个类，电影和演员。\nmysql使用orm框架sqlalchemy 下面是mysql实体类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 \u0026#34;\u0026#34;\u0026#34;实体类文件.\u0026#34;\u0026#34;\u0026#34; from sqlalchemy import String, Text, Integer from sqlalchemy.orm import DeclarativeBase from sqlalchemy.orm import Mapped from sqlalchemy.orm import mapped_column class Base(DeclarativeBase): pass class Actor(Base): __tablename__ = \u0026#39;actor\u0026#39; actor_id: Mapped[int] = mapped_column(primary_key=True) actor_bio: Mapped[str] = mapped_column(Text) actor_chName: Mapped[str] = mapped_column(String(100)) actor_foreName: Mapped[str] = mapped_column(String(100)) actor_nationality: Mapped[str] = mapped_column(String(100)) actor_constellation: Mapped[str] = mapped_column(String(100)) actor_birthPlace: Mapped[str] = mapped_column(String(100)) actor_birthDay: Mapped[str] = mapped_column(String(100)) actor_repWorks: Mapped[str] = mapped_column(String(100)) actor_achiem: Mapped[str] = mapped_column(Text) actor_brokerage: Mapped[str] = mapped_column(String(100)) class Movie(Base): __tablename__ = \u0026#39;movie\u0026#39; movie_id: Mapped[int] = mapped_column(primary_key=True) movie_bio: Mapped[str] = mapped_column(Text) movie_chName: Mapped[str] = mapped_column(String(100)) movie_foreName: Mapped[str] = mapped_column(String(100)) movie_prodTime: Mapped[str] = mapped_column(String(100)) movie_prodCompany: Mapped[str] = mapped_column(String(100)) movie_director: Mapped[str] = mapped_column(String(100)) movie_screenwriter: Mapped[str] = mapped_column(String(100)) movie_genre: Mapped[str] = mapped_column(String(100)) movie_star: Mapped[str] = mapped_column(Text) movie_length: Mapped[str] = mapped_column(String(100)) movie_rekeaseTime: Mapped[str] = mapped_column(String(100)) movie_length: Mapped[str] = mapped_column(String(100)) movie_achiem: Mapped[str] = mapped_column(Text) class ActorToMovie(Base): __tablename__ = \u0026#39;actor_movie_id\u0026#39; actor_movie_id: Mapped[int] = mapped_column(primary_key=True) actor_id: Mapped[int] = mapped_column(Integer) movie_id: Mapped[int] = mapped_column(Integer) class Genre(Base): __tablename__ = \u0026#39;genre\u0026#39; genre_id: Mapped[int] = mapped_column(primary_key=True) genre_name: Mapped[str] = mapped_column(String(100)) class MovieToGenre(Base): __tablename__ = \u0026#39;movie_genre_id\u0026#39; movie_genre_id: Mapped[int] = mapped_column(primary_key=True) movie_id: Mapped[int] = mapped_column(primary_key=True) genre_id: Mapped[int] = mapped_column(primary_key=True) neo4j使用ogm框架py2neo neo4j实体类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from py2neo.ogm import Model, Property, RelatedFrom, RelatedTo class Movie(Model): __primarylable__ = \u0026#39;Movie\u0026#39; movie_id = Property() movie_bio = Property() movie_chName = Property() movie_foreName = Property() movie_prodTime = Property() movie_prodCompany = Property() movie_director = Property() movie_screenwriter = Property() movie_genre = Property() movie_star = Property() movie_length = Property() movie_rekeaseTime = Property() movie_length = Property() movie_achiem = Property() actors = RelatedFrom(\u0026#34;Actor\u0026#34;, \u0026#34;ACTED_IN\u0026#34;) class Actor(Model): # 标签 __primarylable__ = \u0026#34;Actor\u0026#34; # 属性 actor_id = Property() actor_bio = Property() actor_chName = Property() actor_foreName = Property() actor_nationality = Property() actor_constellation = Property() actor_birthPlace = Property() actor_birthDay = Property() actor_repWorks = Property() actor_achiem = Property() actor_brokerage = Property() acted_in = RelatedTo(Movie) 图谱构建 从mysql中查询数据并存到neo4j中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 from py2neo import Relationship from py2neo.ogm import Repository from sqlalchemy import create_engine from sqlalchemy import select from sqlalchemy.orm import Session from custom_model import neo4j_model, mysql_model def covertor_actor(mysql_actor: mysql_model.Actor): neo4j_actor = neo4j_model.Actor() neo4j_actor.actor_id = mysql_actor.actor_id neo4j_actor.actor_bio = mysql_actor.actor_bio neo4j_actor.actor_chName = mysql_actor.actor_chName neo4j_actor.actor_foreName = mysql_actor.actor_foreName neo4j_actor.actor_nationality = mysql_actor.actor_nationality neo4j_actor.actor_constellation = mysql_actor.actor_constellation neo4j_actor.actor_birthPlace = mysql_actor.actor_birthPlace neo4j_actor.actor_birthDay = mysql_actor.actor_birthDay neo4j_actor.actor_repWorks = mysql_actor.actor_repWorks neo4j_actor.actor_achiem = mysql_actor.actor_achiem neo4j_actor.actor_brokerage = mysql_actor.actor_brokerage return neo4j_actor def covertor_movie(actor_movie: mysql_model.Movie): neo4j_movie = neo4j_model.Movie() neo4j_movie.movie_id = actor_movie.movie_id neo4j_movie.movie_bio = actor_movie.movie_bio neo4j_movie.movie_chName = actor_movie.movie_chName neo4j_movie.movie_foreName = actor_movie.movie_foreName neo4j_movie.movie_prodTime = actor_movie.movie_prodTime neo4j_movie.movie_prodCompany = actor_movie.movie_prodCompany neo4j_movie.movie_director = actor_movie.movie_director neo4j_movie.movie_screenwriter = actor_movie.movie_screenwriter neo4j_movie.movie_genre = actor_movie.movie_genre neo4j_movie.movie_star = actor_movie.movie_star neo4j_movie.movie_length = actor_movie.movie_length neo4j_movie.movie_rekeaseTime = actor_movie.movie_rekeaseTime neo4j_movie.movie_length = actor_movie.movie_length neo4j_movie.movie_achiem = actor_movie.movie_achiem return neo4j_movie class ActorMovieKG: def __init__(self): self.repo = Repository(\u0026#34;bolt://neo4j@127.0.0.1:7687\u0026#34;, password=\u0026#34;123456\u0026#34;) self.engine = create_engine(\u0026#39;mysql+pymysql://root:123456@127.0.0.1:3306/kg\u0026#39;) self.session = Session(self.engine) def build_graph(self): self.build_actor() self.build_movie() self.build_rel() def build_movie(self): stmt_movie = select(mysql_model.Movie) for actor_movie in self.session.scalars(stmt_movie): neo4j_movie = covertor_movie(actor_movie) self.repo.create(neo4j_movie) def build_actor(self): stmt_actor = select(mysql_model.Actor) for actor_mysql in self.session.scalars(stmt_actor): neo4j_actor = covertor_actor(actor_mysql) self.repo.create(neo4j_actor) def build_rel(self): stmt = select(mysql_model.ActorToMovie) for element in self.session.scalars(stmt): actor = self.repo.match(neo4j_model.Actor).where(id=element.actor_id).first() movie = self.repo.match(neo4j_model.Movie).where(id=element.movie_id).first() relation_ship = Relationship(actor, \u0026#34;ACTED_IN\u0026#34;, movie) self.repo.create(relation_ship) if __name__ == \u0026#39;__main__\u0026#39;: kg = ActorMovieKG() kg.build_graph() print(\u0026#34;建立知识图谱完成\u0026#34;) 知识图谱使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from py2neo.ogm import Repository from custom_model.neo4j_model import Actor class KGClient: def __init__(self): self.repo = Repository(\u0026#34;bolt://neo4j@127.0.0.1:7687\u0026#34;, password=\u0026#34;123456\u0026#34;) def build_graph(self): cypher = \u0026#34;\u0026#34;\u0026#34;CALL gds.graph.project( \u0026#39;ActorMovieGraph\u0026#39;, [\u0026#39;Actor\u0026#39;, \u0026#39;Movie\u0026#39;], \u0026#39;ACTED_IN\u0026#39; ); \u0026#34;\u0026#34;\u0026#34; self.repo.graph.run(cypher) def query_similarity(self, name: str): \u0026#34;\u0026#34;\u0026#34;找出演员中的紧密程度\u0026#34;\u0026#34;\u0026#34; cypher = f\u0026#34;\u0026#34;\u0026#34;CALL gds.nodeSimilarity.stream(\u0026#39;ActorMovieGraph\u0026#39;) YIELD node1, node2, similarity WITH gds.util.asNode(node1) AS actor1, gds.util.asNode(node2) AS actor2, similarity WHERE actor1.actor_chName = \u0026#39;{name}\u0026#39; RETURN actor1.actor_chName, actor2.actor_chName, similarity ORDER BY similarity DESCENDING \u0026#34;\u0026#34;\u0026#34; result = self.repo.graph.run(cypher).data() print(result) def query_all_movies(self, name: str): actor = self.repo.match(Actor).where( actor_chName=name ).first() if actor is None: raise ValueError(\u0026#39;input error!\u0026#39;) for movie in actor.acted_in: print(movie.movie_chName) if __name__ == \u0026#39;__main__\u0026#39;: kg_client = KGClient() # kg_client.build_graph() # kg_client.query_all_movies(\u0026#34;张家辉\u0026#34;) kg_client.query_similarity(\u0026#34;鲍方\u0026#34;) 结果展示 图谱展示： 查询和鲍方合作的明星，目前actor_to_movie表中的数据太少了，建立的联系不多，只查询出来2个 代码地址 ActorMovieKG\n参考资料 从零开始构建影视类知识图谱（一）半结构化数据的获取 - 知乎 (zhihu.com)\n刘焕勇老师的github项目QABasedOnMedicaKnowledgeGraph\n","date":"2023-07-07T23:49:21+08:00","image":"https://ichigo-xin.github.io/imgs/neo4j_kg1.png","permalink":"https://ichigo-xin.github.io/p/neo4j%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E4%BD%BF%E7%94%A8neo4j%E6%9E%84%E5%BB%BA%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/","title":"Neo4j和知识图谱：使用Neo4j构建知识图谱"},{"content":"在本篇文章中，我会对Neo4j Graph Data Science进行介绍，并且使用其中的算法做相似分析，这样可以让你更快的了解Neo4j Graph Data Science，并将其应用到实践中。\n本文是全系列中的第2/3篇\nNeo4j和知识图谱：Neo4j安装和使用\nNeo4j和知识图谱：Neo4j内置算法库的安装和使用\nNeo4j和知识图谱：使用Neo4j构建知识图谱\nNeo4j Graph Data Science介绍 The Neo4j Graph Data Science (GDS) library provides efficiently implemented, parallel versions of common graph algorithms, exposed as Cypher procedures. Additionally, GDS includes machine learning pipelines to train predictive supervised models to solve graph problems, such as predicting missing relationships.\n这是官网的介绍，接下来我也将称Neo4j Graph Data Science 为GDS。GDS提供了图算法，同时也可以用于机器学习。\n根据处理问题类型，算法分为以下几类：\n中心性\n社区\n相似度\n路径寻找\n节点嵌入\n拓扑链路预测\n这篇文章后面会介绍相似分析的案例。\nGDS安装 下载GDS包，下载地址\n1 2 3 4 5 6 7 8 9 10 将neo4j-graph-data-science-2.4.0.jar放入plugins目录下修改conf文件 vim conf/neo4j.conf dbms.security.procedures.unrestricted=my.extensions.example,my.procedures.*,gds.* dbms.security.procedures.allowlist=apoc.coll.*,apoc.load.*,gds.* 重启neo4j，bin/neo4j restart 在web控制台中输入RETURN gds.version();就可以查询是否安装成功 相似分析 相似分析主要是通过分析两个节点的共有相邻的节点来进行相似分析的。\n对于两个集合A和B，Jaccard相似度计算为：\n重叠系数使用下面的公式:\n对于数据库中的两个节点n和m，A就是和n所有相邻的节点的集合，同样的B是m相邻节点的集合\nNeo4j中的相似算法提供了许多有用的功能，适用于各种场景。以下是一些常见的使用场景：\n推荐系统：通过计算节点之间的相似性，可以构建基于内容或基于协同过滤的推荐系统。相似算法（如相似度计算或最短路径）可以帮助发现相似的用户、产品或兴趣，并向用户提供个性化的推荐。\n社交网络分析：相似算法可以帮助发现社交网络中的相似用户、群组或兴趣。例如，可以使用相似度算法（如Jaccard相似系数）来寻找在兴趣或活动上具有相似性的用户。\n产品推荐：相似算法可以帮助发现产品之间的相似性，从而实现商品推荐和交叉销售。通过计算产品之间的相似度，可以根据用户的购买历史或兴趣，向其推荐类似的产品。\n知识图谱分析：相似算法可以用于分析和比较知识图谱中的实体、关系或概念。通过计算实体之间的相似度，可以发现潜在的关联和模式，并进行语义推理。\n相似分析实战 数据准备 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 CREATE (alice:Person {name: \u0026#39;Alice\u0026#39;}), (bob:Person {name: \u0026#39;Bob\u0026#39;}), (carol:Person {name: \u0026#39;Carol\u0026#39;}), (dave:Person {name: \u0026#39;Dave\u0026#39;}), (eve:Person {name: \u0026#39;Eve\u0026#39;}), (guitar:Instrument {name: \u0026#39;Guitar\u0026#39;}), (synth:Instrument {name: \u0026#39;Synthesizer\u0026#39;}), (bongos:Instrument {name: \u0026#39;Bongos\u0026#39;}), (trumpet:Instrument {name: \u0026#39;Trumpet\u0026#39;}), (rice:Food1 {name: \u0026#39;Rice\u0026#39;}), (pizza:Food1 {name: \u0026#39;Pizza\u0026#39;}), (noodle:Food1 {name: \u0026#39;Noodle\u0026#39;}), (fish:Food1 {name: \u0026#39;Fish\u0026#39;}), (pig:Food1 {name: \u0026#39;Pig\u0026#39;}), (alice)-[:LIKES]-\u0026gt;(guitar), (alice)-[:LIKES]-\u0026gt;(synth), (alice)-[:LIKES]-\u0026gt;(bongos), (bob)-[:LIKES]-\u0026gt;(guitar), (bob)-[:LIKES]-\u0026gt;(synth), (carol)-[:LIKES]-\u0026gt;(bongos), (dave)-[:LIKES]-\u0026gt;(guitar), (dave)-[:LIKES {strength: 1.5}]-\u0026gt;(trumpet), (dave)-[:LIKES]-\u0026gt;(bongos); MATCH (alice:Person {name: \u0026#39;Alice\u0026#39;}), (rice:Food1 {name: \u0026#39;Rice\u0026#39;}) CREATE (alice)-[:EAT]-\u0026gt;(rice); MATCH (alice:Person {name: \u0026#39;Alice\u0026#39;}), (pizza:Food1 {name: \u0026#39;Pizza\u0026#39;}) CREATE (alice)-[:EAT]-\u0026gt;(pizza); MATCH (alice:Person {name: \u0026#39;Alice\u0026#39;}), (noodle:Food1 {name: \u0026#39;Noodle\u0026#39;}) CREATE (alice)-[:EAT]-\u0026gt;(noodle); MATCH (bob:Person {name: \u0026#39;Bob\u0026#39;}), (fish:Food1 {name: \u0026#39;Fish\u0026#39;}) CREATE (bob)-[:EAT]-\u0026gt;(fish); MATCH (bob:Person {name: \u0026#39;Bob\u0026#39;}), (pizza:Food1 {name: \u0026#39;Pizza\u0026#39;}) CREATE (bob)-[:EAT]-\u0026gt;(pizza); MATCH (bob:Person {name: \u0026#39;Bob\u0026#39;}), (noodle:Food1 {name: \u0026#39;Noodle\u0026#39;}) CREATE (bob)-[:EAT]-\u0026gt;(noodle); MATCH (carol:Person {name: \u0026#39;Carol\u0026#39;}), (fish:Food1 {name: \u0026#39;Fish\u0026#39;}) CREATE (carol)-[:EAT]-\u0026gt;(fish); MATCH (dave:Person {name: \u0026#39;Dave\u0026#39;}), (pizza:Food1 {name: \u0026#39;Pizza\u0026#39;}) CREATE (dave)-[:EAT]-\u0026gt;(pizza); 这样我们就建立了一个如下的关系图 建立投影 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 CALL gds.graph.project( \u0026#39;myGraph\u0026#39;, [\u0026#39;Person\u0026#39;, \u0026#39;Instrument\u0026#39;], { LIKES: { properties: { strength: { property: \u0026#39;strength\u0026#39;, defaultValue: 1.0 } } } } ); CALL gds.graph.project( \u0026#39;myGraph1\u0026#39;, [\u0026#39;Person\u0026#39;, \u0026#39;Instrument\u0026#39;, \u0026#39;Food1\u0026#39;], { EAT: { type: \u0026#39;EAT\u0026#39;, properties: { strength: { property: \u0026#39;strength\u0026#39;, defaultValue: 0.5 } } }, LIKES: { type: \u0026#39;LIKES\u0026#39;, properties: { strength: { property: \u0026#39;strength\u0026#39;, defaultValue: 1.0 } } } } ); 这样我们就建立了两个投影，graph中包含了Person和Instrument节点，graph1中包含了Person、Instrument和Food1节点\n计算相似度 1.计算所有节点的相似度\n1 2 3 4 CALL gds.nodeSimilarity.stream(\u0026#39;myGraph\u0026#39;) YIELD node1, node2, similarity RETURN gds.util.asNode(node1).name AS Person1, gds.util.asNode(node2).name AS Person2, similarity ORDER BY similarity DESCENDING, Person1, Person2 语法解析：\nCALL gds.nodeSimilarity.stream(\u0026lsquo;myGraph\u0026rsquo;) 在myGraph投影中使用nodeSimilarity相似分析算法 YIELD node1, node2, similarity 使用节点node1、node2和相似度similarity RETURN gds.util.asNode(node1).name AS Person1, gds.util.asNode(node2).name AS Person2, similarity 返回结果 ORDER BY similarity DESCENDING, Person1, Person2 排序方式 2.计算myGraph投影中与Alice的相似度\n1 2 3 4 5 6 CALL gds.nodeSimilarity.stream(\u0026#39;myGraph\u0026#39;) YIELD node1, node2, similarity WITH gds.util.asNode(node1) AS person1, gds.util.asNode(node2) AS person2, similarity WHERE person1.name = \u0026#39;Alice\u0026#39; RETURN person1.name AS Person1, person2.name AS Person2, similarity ORDER BY similarity DESCENDING 3.计算myGraph1投影中与Alice的相似度\n1 2 3 4 5 6 CALL gds.nodeSimilarity.stream(\u0026#39;myGraph1\u0026#39;) YIELD node1, node2, similarity WITH gds.util.asNode(node1) AS person1, gds.util.asNode(node2) AS person2, similarity WHERE person1.name = \u0026#39;Alice\u0026#39; RETURN person1.name AS Person1, person2.name AS Person2, similarity ORDER BY similarity DESCENDING 4.添加关系之后再计算与Alice的相似度 需要删除投影之后再重新建立（投影在建立的时候就已经固定了，更新了关系之后需要更新投影）\n1 2 3 4 5 6 7 8 MATCH (dave:Person {name: \u0026#39;Dave\u0026#39;}), (rice:Food1 {name: \u0026#39;Rice\u0026#39;}), (pizza:Food1 {name: \u0026#39;Pizza\u0026#39;}) ,(synthesizer:Instrument {name:\u0026#34;Synthesizer\u0026#34;}) CREATE (dave)-[:LIKES]-\u0026gt;(synthesizer) (dave)-[:EAT]-\u0026gt;(rice), (dave)-[:EAT]-\u0026gt;(pizza); CALL gds.graph.drop(\u0026#39;myGraph1\u0026#39;) 执行结果如下： 现在是alice最相似的是bob了\n","date":"2023-07-03T20:52:02+08:00","image":"https://ichigo-xin.github.io/imgs/DM_20230703230529_001.png","permalink":"https://ichigo-xin.github.io/p/neo4j%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1neo4j%E5%86%85%E7%BD%AE%E7%AE%97%E6%B3%95%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/","title":"Neo4j和知识图谱：Neo4j内置算法库的安装和使用"},{"content":"这篇文章介绍一个小小的检测脚本，用来检测写的博客有没有个人信息，以及如何在电脑上快速配置命令方便使用。\n需要电脑上安装了python3，并且配置了环境变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 文件名 check_personnal_info.py import sys def detect_personal_info(file_path): target_strings = [\u0026#39;root\u0026#39;, \u0026#39;729\u0026#39;] # 替换为你要检测的个人信息字符串列表 with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as file: lines = file.readlines() for i, line in enumerate(lines): for target_string in target_strings: if target_string.lower() in line.lower(): print(f\u0026#34;个人信息字符串 \u0026#39;{target_string}\u0026#39; 出现在第 {i+1} 行：\\n{line}\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: if len(sys.argv) \u0026lt; 2: print(\u0026#34;请提供文件名作为参数\u0026#34;) else: file_path = sys.argv[1] detect_personal_info(file_path) 然后在e盘新建一个文件夹 E:\\PythonScript，里面用于存放bat文件和py脚本，将E:\\PythonScript添加到环境变量里面（在系统高级设置里面，设置环境变量，将E:\\PythonScript添加到path里面） 在PythonScript文件家里面新建check_personnal_info.py文件，将代码copy进去 在该文件夹里面新建check.bat文件,文件内容如下\n1 @python.exe E:\\PythonScript\\check_personnal_info.py %* 在对应博客目录执行 check + 文件名 即可，如 check check.md ","date":"2023-07-01T14:38:30+08:00","permalink":"https://ichigo-xin.github.io/p/%E6%A3%80%E6%B5%8B%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E8%84%9A%E6%9C%AC%E5%92%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"检测博客中的个人信息脚本和环境配置"},{"content":"在本篇文章中，我会对Neo4j图数据库、查询语句Cypher进行介绍，这样可以让你更容易掌握这门技术。其中主要包括Neo4j的安装配置，查询语句Cypher使用。\n本文是全系列中的第1/3篇\nNeo4j和知识图谱：Neo4j安装和使用\nNeo4j和知识图谱：Neo4j内置算法库的安装和使用\nNeo4j和知识图谱：使用Neo4j构建知识图谱\nNeo4j和知识图谱：项目中使用py2neo的ogm框架构建知识图谱\nNeo4j介绍 Neo4j是一种广泛使用的图形数据库管理系统，专注于存储和处理具有复杂关系的数据。它使用图形模型来表示数据，其中节点表示实体，边表示实体之间的关系。Neo4j提供了一种高效灵活的方式来处理和查询这些图形数据。\nNeo4j的使用场景非常丰富，适用于多个领域和行业。以下是一些常见的使用场景：\n社交网络分析：Neo4j可以存储和分析社交网络中的用户关系、兴趣和活动。它能够高效地执行复杂的关系查询，例如查找朋友的朋友、查找共同兴趣的人等。 推荐系统：Neo4j可以帮助构建个性化的推荐系统。通过建模用户、产品和其它相关属性之间的关系，Neo4j能够快速查询和发现潜在的兴趣和推荐。 知识图谱和语义网络：Neo4j能够存储和查询知识图谱，这是一种表示实体之间关系和属性的结构化数据模型。知识图谱广泛应用于搜索引擎、智能助手和推荐系统等领域。 这些场景用关系型数据库实现非常困难，这就是图数据库发挥作用的地方。\nNeo4j安装 Neo4j有社区版和企业版。这里我们选择社区版，同时Neo4j使用Java进行开发的，因此和JDK版本有着对应关系，4.x的版本选择jdk11，因为后续会安装算法库，再加上项目开发的需求就选择了neo4j-community-4.4.22-unix的版本。\nNeo4j version Neo4j Graph Data Science 5.9 2.4, 2.3.9 or later 5.8 2.4, 2.3.6 or later 5.7 2.4, 2.3.3 or later 5.6 2.4, 2.3.2 or later 5.5 2.4, 2.3.1 or later 5.4 2.4, 2.3 5.3 2.4, 2.3 5.2 2.4, 2.3 5.1 2.4, 2.3 4.4.9 or later 2.4, 2.3 具体版本要求官网地址\n下载地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 安装步骤 安装前需要安装jdk11 1.解压安装包 tar -xf neo4j-community-4.4.22-unix.tar.gz 2.配置neo4j cd neo4j-community-4.4.22/ vim conf/neo4j.conf dbms.memory.heap.initial_size=4g #根据服务器的内存进行修改 dbms.memory.heap.max_size=4g #根据服务器的内存进行修改 dbms.default_listen_address=0.0.0.0 #设置可以远程访问 dbms.connector.http.listen_address=:7474 3.启动 bin/neo4j start 看下服务有没有启动 ps -ef | grep neo 4.打开浏览器，并访问 http://ip:7474/ ，这将打开Neo4j的Web控制台 用户名和密码 neo4j/neo4j Cypher的使用 用cypher查询neo4j就相当于用sql查询mysql\n创建节点 创建单个节点\n1 create (n:Person {name:\u0026#34;孙悟空\u0026#34;}) 创建多个节点\n1 CREATE (n:Person {name: \u0026#34;唐三藏\u0026#34;}), (m:Person {name: \u0026#34;猪八戒\u0026#34;, weapon: \u0026#34;九齿钉耙\u0026#34;}) 如果没有定义model的话，对于一个节点是可以随意配置属性的，上面的猪八戒中就多了个武器的属性\n创建关系 语法: ()代表实体，-[]-\u0026gt;代表关系\n1 create ()-[]-\u0026gt;() 创建已有节点的关系\n1 2 3 MATCH (n:Person ) match (n:Person{name:\u0026#34;孙悟空\u0026#34;}), (m:Person{name:\u0026#34;猪八戒\u0026#34;}) create (n)-[r:shidi{name:\u0026#34;师弟\u0026#34;}]-\u0026gt;(m) 创建节点和关系\n删除节点 1 2 match (n:Person {name:\u0026#39;唐三藏\u0026#39;}) delete n 删除关系 1 2 match (n:Person {name:\u0026#34;李靖\u0026#34;})-[r:child]-\u0026gt;(m:Person {name:\u0026#39;哪吒\u0026#39;}) delete r 修改属性值 1 2 match (n:Person {name:\u0026#34;孙悟空\u0026#34;}) set n.weapon = \u0026#34;如意金箍棒\u0026#34; 查询 就是match，然后接个return\n1 2 3 4 5 6 7 match (n:Person {name:\u0026#34;孙悟空\u0026#34;}) return n 使用where进行过滤 match (n:Person ) where n.name = \u0026#34;猪八戒\u0026#34; return n 使用limit进行限制 match (n:Person ) return n limit 2 ","date":"2023-06-28T21:00:04+08:00","permalink":"https://ichigo-xin.github.io/p/neo4j%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1neo4j%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/","title":"Neo4j和知识图谱：Neo4j安装和使用"}]
=======
[{"content":"Algorithm 125. 验证回文串\n用双指针解决，首末两个指针同时向中间逼近\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution: def isPalindrome(self, s: str) -\u0026gt; bool: s = \u0026#39;\u0026#39;.join(filter(str.isalnum, s.lower())) if len(s) \u0026lt;= 1: return True left = 0 right = len(s) - 1 while left \u0026lt; right: if s[left] != s[right]: return False left += 1 right -= 1 return True 看他人的题解中有两行的写法\n1 2 3 4 class Solution: def isPalindrome(self, s: str) -\u0026gt; bool: s = \u0026#39;\u0026#39;.join(filter(str.isalnum, s.lower())) return s == s[::-1] Review Understanding Multiprocessing and Multithreading in Python | HackerNoon\n这篇文章介绍了python里面的多线程和多进程。\npython里的多线程也是有共享内存的，但是和Java不同的是由于GIL的存在，其实python里的多线程是加了全局锁的，只会在一个cpu上运行，其实不是真正的并行执行。\npython里的多进程，就是操作系统多个进程同时执行。\nTips 记录一下最近用到的git操作\n1.rebase的时候解决冲突，把自己的代码给删除了。在idea的控制台上看提交历史也没有需要的代码。\n解决方法：\ngit reflog.找到rebase之前的提交的hash值，确定丢失的代码在哪个提交里\n使用git cherry-pick （hash值）,引入提交\n解决冲突\nShare 第164期 | 你工作开心吗？ (geekbang.org) 这是以前看到的一篇文章，讲的职业倦怠。\n总结来说，职业倦怠是不可避免，但是我们采取措施措施，做出改变。之前也看过一篇文章说，职业倦怠也是周期性的，就像脉冲一下，过一阵子又有了。\n在我看来做到工作和生活平衡，然后给自己充电，有时候做些稍微有些挑战性的工作，就可以减少个人倦怠的情绪。\n","date":"2023-09-14T19:04:17+08:00","permalink":"https://ichigo-xin.github.io/p/arts-week4/","title":"ARTS Week4"},{"content":"Algorithm 旋转链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution: def rotateRight(self, head: Optional[ListNode], k: int) -\u0026gt; Optional[ListNode]: if k == 0 or not head or not head.next: return head n = 1 cur = head while cur.next: n += 1 cur = cur.next if (add := n - k % n) == n: return head cur.next = head while add: cur = cur.next add -= 1 res = cur.next cur.next = None return res Review pa中使用lombok可能会导致的问题\n1.@Data或者是@EqualsAndHashCode注解，一般情况下主键id都是由数据库自动生成的，这时候即使其他属性值相同的对象的hash值也是不相同的\n2.@ToString,在有多对多的关系中，如果没有设置懒加载，直接打印的话，就会出现a引用b，b引用a，这样无线循环，栈溢出，最好使用exclude\n3.就是不要忘记添加无参构造函数\nTips 1.py2neo中rel = self.repository.graph.match((record.node, handler.node,), r_type=\u0026ldquo;be_handled\u0026rdquo;).first()方法中，如果这个rel是没有任何属性值的，那结果就是None\n2.使用jpa的findall方法报错数组越界，发现是实体类里面有个枚举字段，里面还没有定义任何枚举值。\nShare 最近看到一篇大数据杀熟文章的分析，同一个商品，商家和平台根据用户数据找出不同客户的最高承受价格，这就是大数据杀熟。从用户的角度来说，只有随着个人隐私的数据的保护才能避免被杀熟，现阶段还是无法避免的。\n","date":"2023-08-29T18:04:17+08:00","permalink":"https://ichigo-xin.github.io/p/arts-week3/","title":"ARTS Week3"},{"content":"Algorithm 这周继续回溯算法，题目是n皇后\n解析:直接用一个数组来表示放置位置，例如[1,3,0,2]表示第一行放1的位置，第二行放3的职位\u0026hellip;，path表示路径，进入前先判断是否合法，dfs之前将当前节点加入path，dfs之后做反操作，状态重置。然后就是判断是否合法，同一列就是值在集合里面，斜着的话打个比方,目前path是[1.3],现在第三行加入2，|2-3|=|2的下标-3的下标|\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution: def solveNQueens(self, n: int) -\u0026gt; list[list[str]]: path = [] result = [] self.dfs(0, n, path, result) return result def dfs(self, index, n, path, result): if index == n: result.append(self.trans(path, n)) for i in range(n): if not self.is_valid(i, path): continue path.append(i) self.dfs(index + 1, n, path, result) path.pop() def is_valid(self, num, path): for i in range(len(path)): if num in path: return False if abs(path[i] - num) == abs(len(path) - i): return False return True def trans(self, path, n): \u0026#34;\u0026#34;\u0026#34;转换为输出结果\u0026#34;\u0026#34;\u0026#34; temp = \u0026#34;.\u0026#34; * n result = [] for item in path: result.append(temp[:item] + \u0026#34;Q\u0026#34; + temp[item+1:]) return result Review Spring Data JPA中@Joincolumn和@mappedBy的区别 结论：@Joincolumn在关系拥有端定义映射，然后这个关系的另一端使用mappedBy进行定义\n发现这个网站是Java生态相关的，主要是spring和restful，后面可以多来逛逛。\nTips 项目开发过程中可以开启feign的日志功能方便接口开发测试，配置文件中开启full级别\nShare 今天看了极客时间的学习进度，《左耳听风》专栏上的进度是67%。这个专栏我是断断续续学习的，应该是从前年开始看的，前年看了一些章节，去年也看了一些章节。感觉入这行时间不长的原因，好多章节看得懵懵懂懂，像编程范式这些章节就是这样。让我留下深刻印象的主要还是耗子叔的一些观点吧。\n查看官网资料。我学习技术也是这样做的，好的博客，官网，极客时间专栏这些我都看，我后面也会去看官方文档。我自己也写博客，主要是记录和分享，但是我还是推荐大家去官网查阅资料，所以我在博客里面都会加上官网的链接。 学习几门语言。目前主要Java开发,工作中写过半年c++（菜鸡一个），python和go都会一点吧。 扎实基本功。算法方面在leetcode做了100多道题，每道题做几遍，隔几天做一次，通过提交次数将近500次。计算机网络方面还没开始，打算后续找本书看，极客时间上也有相关专栏，最近在看spring相关的资料，等这个模块结束后就开始学习计算机网络。 ","date":"2023-08-23T17:36:11+08:00","permalink":"https://ichigo-xin.github.io/p/arts-week2/","title":"ARTS Week2"},{"content":"Algorithm 题目：全排列\n最近工作中使用python搭建一个知识图谱服务，之前都是用python写一些脚本，而且都是参考其他模块的代码，感觉都是照葫芦画瓢，趁着这个项目好好学习下python，也打算在刷算法题也用python写，强行走出舒适区。\n题目分析：全排列使用的是回溯算法，和深度优先遍历差不多。就是需要使用递归，在处理当前层进入下一层之前需要添加到状态变量里面，之后返回到当前层进入另一个选择时将刚才加入的部分进行反操作。\n回溯算法有三个关键词：状态（路径）、选择列表、结束条件 在当前状态时，for循环选择列表，然后选择一个进入，这时候就需要把选择加入到状态里面，当第一条路走完，回到这个点的时候，就需要进行状态重置，然后选择另一个进入。就这样做完所有的遍历。 参考文章\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lass Solution: def permute(self, nums: list[int]) -\u0026gt; list[list[int]]: res = [] path = [] if len(nums) == 0: return res self.dfs(nums, res, path, 0) return res def dfs(self, nums: list, res: list, path, level): if len(path) == len(nums): res.append(path.copy()) for num in nums: if num in path: continue path.append(num) self.dfs(nums, res, path, level + 1) path.pop() Review python web框架Django和FastAPI的对比 文章从性能、路由、数据库支持、模版、安全、社区支持、部署和开发这几个方面对这两个框架进行了对比\n性能：FastAPI使用的是异步框架，性能更快，Django使用的是同步框架，对流程的控制更加容易些 路由：FastAPI是针对api设计的，写路由更加方便\n数据库支持：Django内置了ORM映射框架\n模版和前端集成：Django内置了一个模版操作系统，更加容易，FastAPI则是凸显了他在API集成方面的优势，与VUE和Angular集成方便\n安全：在sql注入攻击和XSS攻击，两个框架都是做了保护的。Django有自己的权限验证系统\n社区支持：两个社区都很活跃\n部署：都有各自部署领域\n开发：FastAPI开发更快\nTips py2neo中，如果使用cypher语句先match节点，然后再创建节点关系的方式的话，就会创建重复关系，直接使用Relationship就不会创建重复关系。尽量使用这种方式，如果使用cypher语句的话先要判断关系是否存在。\n1 2 3 4 5 6 7 8 9 10 event = self.repository.graph.nodes.match( \u0026#34;Event\u0026#34;, event_id=event_po.event_id ).first() record = self.repository.graph.nodes.match( \u0026#34;Record\u0026#34;, record_id=event_po.record_id ).first() if record is None or event is None: continue rel = Relationship(record, \u0026#34;has_event\u0026#34;, event) self.repository.graph.create(rel) Share 做一件事之前做一定的准备是有必要的。但是一直停留在想的阶段，只会造成内耗，最重要的还是行动起来。在做这件事的过程中自然而然会出现许多问题，一个一个解决就可以了。行动起来最重要！\n","date":"2023-08-16T23:35:48+08:00","permalink":"https://ichigo-xin.github.io/p/arts-week1/","title":"ARTS Week1"},{"content":"在本篇文章中，我将手写模拟Spring整合Jpa流程。\n项目搭建 项目依赖:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.data\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.28\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-entitymanager\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.4.32.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.22\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 连接池 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring test --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.13\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.data\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-data-bom\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2020.0.14\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package com.xin.config; import com.alibaba.druid.pool.DruidDataSource; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.data.jpa.repository.config.EnableJpaRepositories; import org.springframework.orm.jpa.JpaTransactionManager; import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean; import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter; import org.springframework.transaction.PlatformTransactionManager; import org.springframework.transaction.annotation.EnableTransactionManagement; import javax.sql.DataSource; /** * @author : ichigo-xin * @date 2023/7/18 */ @Configuration @EnableJpaRepositories(basePackages = \u0026#34;com.xin.repository\u0026#34;) @EnableTransactionManagement @ComponentScan(\u0026#34;com.xin\u0026#34;) public class SpringDataConfig { @Bean public DataSource druidDataSource(){ DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setDriverClassName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); druidDataSource.setUrl(\u0026#34;jdbc:mysql://localhost:3306/springdata?serverTimezone=UTC\u0026#34;); druidDataSource.setUsername(\u0026#34;root\u0026#34;); druidDataSource.setPassword(\u0026#34;123456\u0026#34;); return druidDataSource; } @Bean public LocalContainerEntityManagerFactoryBean entityManagerFactory(){ HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter(); adapter.setGenerateDdl(true); adapter.setShowSql(true); LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean(); factory.setDataSource(druidDataSource()); factory.setPackagesToScan(\u0026#34;com.xin.pojo\u0026#34;); factory.setJpaVendorAdapter(adapter); return factory; } @Bean public PlatformTransactionManager transactionManager(){ JpaTransactionManager txManager = new JpaTransactionManager(); txManager.setEntityManagerFactory(entityManagerFactory().getObject()); return txManager; } } pojo类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Entity @Table(name = \u0026#34;tb_customer\u0026#34;) @Getter @Setter @ToString @AllArgsConstructor @NoArgsConstructor public class Customer { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \u0026#34;cust_id\u0026#34;) private Long custId; @Column(name = \u0026#34;cust_name\u0026#34;) private String custName; @Column(name = \u0026#34;cust_address\u0026#34;) private String custAddress; } CustomerRepository:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package com.xin.repository; import com.xin.pojo.Customer; import org.springframework.data.repository.PagingAndSortingRepository; import org.springframework.stereotype.Component; /** * @author: ichigo-xin * @create: 2023-07-18 00:47 * @description: **/ //@Component public interface CustomerRepository extends PagingAndSortingRepository\u0026lt;Customer, Long\u0026gt; { } application:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.xin; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import com.xin.config.SpringDataConfig; import com.xin.pojo.Customer; import com.xin.repository.CustomerRepository; /** * @author: ichigo-xin * @create: 2023-07-26 01:24 * @description: **/ public class Application { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringDataConfig.class); CustomerRepository repository = context.getBean(CustomerRepository.class); Customer customer = repository.findById(1L).get(); System.out.println(customer); } } 手写模拟Spring Data Jpa 在配置类中使用@EnableJpaRepositories(basePackages = \u0026ldquo;com.xin.repository\u0026rdquo;)注解，就是开启spring data jpa，现在是可以查询出数据的。\n我们把这个注解注释掉，此时运行报错：\nNo qualifying bean of type \u0026lsquo;com.xin.repository.CustomerRepository\u0026rsquo; available\n说明没有这个类型的bean，这时候我们就需要去找这个bean没有注入的原因。\n问题原因 spring读取注册BeanDefinition的流程如下：需要创建BeanDefinition，再根据BeanDefinition创建对象（bean的创建就不继续了），我们在这几个类里面打上断点，调试看看。\n在这两个红框的方法内，一个是判断类上面有没有@component注解，另一个是判断这个类是不是接口等\n可以看到如果是一个接口，他就不会注册成beandefinition。\n自定义扫描器将接口也注册成beandefinition 我们自定义扫描器，不排除掉接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package com.xin.my; import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.beans.factory.config.BeanDefinitionHolder; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.context.annotation.ClassPathBeanDefinitionScanner; import org.springframework.context.annotation.ScannedGenericBeanDefinition; import org.springframework.core.type.AnnotationMetadata; import org.springframework.core.type.classreading.MetadataReader; import java.io.IOException; import java.util.Set; /** * @author: ichigo-xin * @create: 2023-07-26 02:19 * @description: **/ public class MyJpaClassPathBeanDefinitionScanner extends ClassPathBeanDefinitionScanner { public MyJpaClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry) { super(registry); } @Override protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) { AnnotationMetadata metadata = beanDefinition.getMetadata(); return metadata.isInterface(); } } 再运行代码，就会报错：\nCaused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.xin.repository.CustomerRepository]: Specified class is an interface\n这说明CustomerRepository作为接口也注册成一个beandefinition了。只是不能进行实例化。在spring当中，每一个bean其实就是一个实例化的对象，那么接口肯定不能实例化的，这里我们就需要使用动态代理了。\n自定义MyJpaProxy，实现JpaRepository接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package com.xin.my; import org.springframework.data.domain.Example; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.domain.Sort; import org.springframework.data.jpa.repository.JpaRepository; import javax.persistence.EntityManager; import java.util.List; import java.util.Optional; /** * @author: ichigo-xin * @create: 2023-07-26 21:08 * @description: **/ public class MyJpaProxy implements JpaRepository { EntityManager em; Class pojoClass; public MyJpaProxy(EntityManager em, Class pojoClass) { this.em = em; this.pojoClass = pojoClass; } @Override public Optional findById(Object id) { System.out.println(\u0026#34;自定义JPA统一实现\u0026#34;); return Optional.of(em.find(pojoClass, id)); } .... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.xin.my; import javax.persistence.EntityManager; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; /** * @author: ichigo-xin * @create: 2023-07-26 21:01 * @description: **/ public class MyJpaInvocationHandler implements InvocationHandler { EntityManager em; Class pojoClass; public MyJpaInvocationHandler(EntityManager em, Class pojoClass) { this.em = em; this.pojoClass = pojoClass; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { MyJpaProxy myJpaProxy = new MyJpaProxy(em, pojoClass); Method jpaMethod = myJpaProxy.getClass().getMethod(method.getName(), method.getParameterTypes()); return jpaMethod.invoke(myJpaProxy, args); } } 我们自定义MyJpaFactoryBean，在getObject方法里面使用Proxy.newProxyInstance(）来创建对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package com.xin.my; import com.xin.repository.CustomerRepository; import org.springframework.beans.factory.FactoryBean; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean; import org.springframework.stereotype.Component; import javax.persistence.EntityManager; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Proxy; import java.lang.reflect.Type; /** * @author: ichigo-xin * @create: 2023-07-26 20:56 * @description: **/ public class MyJpaFactoryBean implements FactoryBean { @Autowired LocalContainerEntityManagerFactoryBean entityManagerFactory; Class\u0026lt;?\u0026gt; repositoryInterface; public MyJpaFactoryBean(Class\u0026lt;?\u0026gt; repositoryInterface) { this.repositoryInterface = repositoryInterface; } @Override public Object getObject() throws Exception { EntityManager em = entityManagerFactory.createNativeEntityManager(null); //获取当前接口的pojo类 ParameterizedType parameterizedType = (ParameterizedType) repositoryInterface.getGenericInterfaces()[0]; Type type = parameterizedType.getActualTypeArguments()[0]; Class clazz = Class.forName(type.getTypeName()); return Proxy.newProxyInstance( CustomerRepository.class.getClassLoader(), new Class[]{repositoryInterface}, new MyJpaInvocationHandler(em, clazz)); } @Override public Class\u0026lt;?\u0026gt; getObjectType() { return repositoryInterface; } } 接下来我们需要在容器加载BeanDefinition的时候将本来应该是实例化接口的步骤，替换成我们上面自定义的实现。\n在 Spring 框架中，BeanDefinitionRegistryPostProcessor 是一个重要的扩展点接口，它允许开发者在容器加载 Bean 定义（BeanDefinition）之后，但在实例化 Bean 之前，对 Bean 定义进行自定义修改或添加新的 Bean 定义。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package com.xin.my; import org.springframework.beans.BeansException; import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor; import org.springframework.core.type.filter.AssignableTypeFilter; import org.springframework.data.repository.Repository; import org.springframework.stereotype.Component; /** * @author: ichigo-xin * @create: 2023-07-26 02:24 * @description: **/ @Component public class MyJpaBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor { @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { MyJpaClassPathBeanDefinitionScanner scanner = new MyJpaClassPathBeanDefinitionScanner(registry); scanner.addIncludeFilter(new AssignableTypeFilter(Repository.class)); scanner.scan(\u0026#34;com.xin.repository\u0026#34;); } @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { } } 同时给MyJpaClassPathBeanDefinitionScanner重写doscan方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.xin.my; import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.beans.factory.config.BeanDefinitionHolder; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.context.annotation.ClassPathBeanDefinitionScanner; import org.springframework.context.annotation.ScannedGenericBeanDefinition; import org.springframework.core.type.AnnotationMetadata; import org.springframework.core.type.classreading.MetadataReader; import java.io.IOException; import java.util.Set; /** * @author: ichigo-xin * @create: 2023-07-26 02:19 * @description: **/ public class MyJpaClassPathBeanDefinitionScanner extends ClassPathBeanDefinitionScanner { public MyJpaClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry) { super(registry); } @Override protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) { AnnotationMetadata metadata = beanDefinition.getMetadata(); return metadata.isInterface(); } @Override protected Set\u0026lt;BeanDefinitionHolder\u0026gt; doScan(String... basePackages) { Set\u0026lt;BeanDefinitionHolder\u0026gt; beanDefinitionHolders = super.doScan(basePackages); for (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) { ScannedGenericBeanDefinition beanDefinition = (ScannedGenericBeanDefinition) beanDefinitionHolder.getBeanDefinition(); String beanClassName = beanDefinition.getBeanClassName(); beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // 修改beanDefinition beanDefinition.setBeanClass(MyJpaFactoryBean.class); } return beanDefinitionHolders; } } 我们在doscan方法中对beanDefinition的BeanClass进行替换。\n运行代码，成功查询出来数据了。 同时我们也可以看下代理对象\n","date":"2023-07-26T21:56:50+08:00","permalink":"https://ichigo-xin.github.io/p/%E6%89%8B%E5%86%99spring%E6%95%B4%E5%90%88jpa%E6%B5%81%E7%A8%8B/","title":"手写Spring整合Jpa流程"},{"content":"在本篇文章中，我会对知识图谱进行介绍，并且会演示如何搭建一个知识图谱，这样你也可以跟着这篇博客搭建知识图谱。本文是全系列中的第3/3篇\nNeo4j和知识图谱：Neo4j安装和使用\nNeo4j和知识图谱：Neo4j内置算法库的安装和使用\nNeo4j和知识图谱：使用Neo4j构建知识图谱\n知识图谱介绍 知识图谱是一种语义化的知识表示形式，它可以将实体、属性和实体之间的关系以图谱的形式呈现出来。知识图谱可以用于自然语言理解、信息检索、智能推荐等领域，是人工智能技术的重要组成部分。\n在知识图谱中，实体通常指现实世界中的事物，如人、地点、组织等，而属性则是实体的特征或属性，如人的年龄、地点的经纬度等。实体之间的关系可以分为不同类型，如属于、工作于、是朋友等。通过建立知识图谱，可以将这些实体和关系以结构化的方式进行表达，从而更好地理解和利用这些知识。\n总之，知识图谱是一种强大的工具，可以帮助我们更好地理解和利用现实世界中的知识，从而实现更智能化的应用和服务。\n知识图谱的构建流程 构建一个知识图谱需要经过以下步骤：\n知识抽取 知识抽取是指从非结构化数据中提取出实体、属性和实体间的关系的过程。这一步通常需要使用自然语言处理技术，如实体识别、关系抽取等。\n知识表示 知识表示是将抽取出的知识以一定的格式进行表示的过程。常用的表示方式有三元组和RDF等。\n知识存储 知识存储是将知识表示存储到数据库中的过程。常用的数据库有图数据库、关系型数据库和文档数据库等。\n知识推理 知识推理是指根据已有的知识推导出新的知识的过程。这一步通常需要使用逻辑推理、规则推理等技术。\n知识应用 知识应用是指将知识图谱应用到具体的应用场景中的过程。如搜索引擎、智能问答、智能客服等。\n知识图谱的搭建大致就是这几个流程，在一个知识图谱项目中，不一定每个步骤都有。比如我接下来的例子中，数据已经以结构化的形式存在数据库中了，不需要做知识抽取的过程，同时知识表示其实就是构建模型的过程。\n搭建一个演员电影知识图谱 项目使用 python + py2neo + neo4j + mysql 进行搭建，项目代码\n1.数据来源于从零开始构建影视类知识图谱（一）半结构化数据的获取 - 知乎 (zhihu.com),在我的github项目里面也有。\n2.数据建模，这里就借用了结构化数据到RDF文件的概念，table对应class，一条记录对应一个实体，记录中的字段对应属性。简化一点，那我们在neo4j数据库中就只有两个类，电影和演员。\nmysql使用orm框架sqlalchemy 下面是mysql实体类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 \u0026#34;\u0026#34;\u0026#34;实体类文件.\u0026#34;\u0026#34;\u0026#34; from sqlalchemy import String, Text, Integer from sqlalchemy.orm import DeclarativeBase from sqlalchemy.orm import Mapped from sqlalchemy.orm import mapped_column class Base(DeclarativeBase): pass class Actor(Base): __tablename__ = \u0026#39;actor\u0026#39; actor_id: Mapped[int] = mapped_column(primary_key=True) actor_bio: Mapped[str] = mapped_column(Text) actor_chName: Mapped[str] = mapped_column(String(100)) actor_foreName: Mapped[str] = mapped_column(String(100)) actor_nationality: Mapped[str] = mapped_column(String(100)) actor_constellation: Mapped[str] = mapped_column(String(100)) actor_birthPlace: Mapped[str] = mapped_column(String(100)) actor_birthDay: Mapped[str] = mapped_column(String(100)) actor_repWorks: Mapped[str] = mapped_column(String(100)) actor_achiem: Mapped[str] = mapped_column(Text) actor_brokerage: Mapped[str] = mapped_column(String(100)) class Movie(Base): __tablename__ = \u0026#39;movie\u0026#39; movie_id: Mapped[int] = mapped_column(primary_key=True) movie_bio: Mapped[str] = mapped_column(Text) movie_chName: Mapped[str] = mapped_column(String(100)) movie_foreName: Mapped[str] = mapped_column(String(100)) movie_prodTime: Mapped[str] = mapped_column(String(100)) movie_prodCompany: Mapped[str] = mapped_column(String(100)) movie_director: Mapped[str] = mapped_column(String(100)) movie_screenwriter: Mapped[str] = mapped_column(String(100)) movie_genre: Mapped[str] = mapped_column(String(100)) movie_star: Mapped[str] = mapped_column(Text) movie_length: Mapped[str] = mapped_column(String(100)) movie_rekeaseTime: Mapped[str] = mapped_column(String(100)) movie_length: Mapped[str] = mapped_column(String(100)) movie_achiem: Mapped[str] = mapped_column(Text) class ActorToMovie(Base): __tablename__ = \u0026#39;actor_movie_id\u0026#39; actor_movie_id: Mapped[int] = mapped_column(primary_key=True) actor_id: Mapped[int] = mapped_column(Integer) movie_id: Mapped[int] = mapped_column(Integer) class Genre(Base): __tablename__ = \u0026#39;genre\u0026#39; genre_id: Mapped[int] = mapped_column(primary_key=True) genre_name: Mapped[str] = mapped_column(String(100)) class MovieToGenre(Base): __tablename__ = \u0026#39;movie_genre_id\u0026#39; movie_genre_id: Mapped[int] = mapped_column(primary_key=True) movie_id: Mapped[int] = mapped_column(primary_key=True) genre_id: Mapped[int] = mapped_column(primary_key=True) neo4j使用ogm框架py2neo neo4j实体类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from py2neo.ogm import Model, Property, RelatedFrom, RelatedTo class Movie(Model): __primarylable__ = \u0026#39;Movie\u0026#39; movie_id = Property() movie_bio = Property() movie_chName = Property() movie_foreName = Property() movie_prodTime = Property() movie_prodCompany = Property() movie_director = Property() movie_screenwriter = Property() movie_genre = Property() movie_star = Property() movie_length = Property() movie_rekeaseTime = Property() movie_length = Property() movie_achiem = Property() actors = RelatedFrom(\u0026#34;Actor\u0026#34;, \u0026#34;ACTED_IN\u0026#34;) class Actor(Model): # 标签 __primarylable__ = \u0026#34;Actor\u0026#34; # 属性 actor_id = Property() actor_bio = Property() actor_chName = Property() actor_foreName = Property() actor_nationality = Property() actor_constellation = Property() actor_birthPlace = Property() actor_birthDay = Property() actor_repWorks = Property() actor_achiem = Property() actor_brokerage = Property() acted_in = RelatedTo(Movie) 图谱构建 从mysql中查询数据并存到neo4j中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 from py2neo import Relationship from py2neo.ogm import Repository from sqlalchemy import create_engine from sqlalchemy import select from sqlalchemy.orm import Session from custom_model import neo4j_model, mysql_model def covertor_actor(mysql_actor: mysql_model.Actor): neo4j_actor = neo4j_model.Actor() neo4j_actor.actor_id = mysql_actor.actor_id neo4j_actor.actor_bio = mysql_actor.actor_bio neo4j_actor.actor_chName = mysql_actor.actor_chName neo4j_actor.actor_foreName = mysql_actor.actor_foreName neo4j_actor.actor_nationality = mysql_actor.actor_nationality neo4j_actor.actor_constellation = mysql_actor.actor_constellation neo4j_actor.actor_birthPlace = mysql_actor.actor_birthPlace neo4j_actor.actor_birthDay = mysql_actor.actor_birthDay neo4j_actor.actor_repWorks = mysql_actor.actor_repWorks neo4j_actor.actor_achiem = mysql_actor.actor_achiem neo4j_actor.actor_brokerage = mysql_actor.actor_brokerage return neo4j_actor def covertor_movie(actor_movie: mysql_model.Movie): neo4j_movie = neo4j_model.Movie() neo4j_movie.movie_id = actor_movie.movie_id neo4j_movie.movie_bio = actor_movie.movie_bio neo4j_movie.movie_chName = actor_movie.movie_chName neo4j_movie.movie_foreName = actor_movie.movie_foreName neo4j_movie.movie_prodTime = actor_movie.movie_prodTime neo4j_movie.movie_prodCompany = actor_movie.movie_prodCompany neo4j_movie.movie_director = actor_movie.movie_director neo4j_movie.movie_screenwriter = actor_movie.movie_screenwriter neo4j_movie.movie_genre = actor_movie.movie_genre neo4j_movie.movie_star = actor_movie.movie_star neo4j_movie.movie_length = actor_movie.movie_length neo4j_movie.movie_rekeaseTime = actor_movie.movie_rekeaseTime neo4j_movie.movie_length = actor_movie.movie_length neo4j_movie.movie_achiem = actor_movie.movie_achiem return neo4j_movie class ActorMovieKG: def __init__(self): self.repo = Repository(\u0026#34;bolt://neo4j@127.0.0.1:7687\u0026#34;, password=\u0026#34;123456\u0026#34;) self.engine = create_engine(\u0026#39;mysql+pymysql://root:123456@127.0.0.1:3306/kg\u0026#39;) self.session = Session(self.engine) def build_graph(self): self.build_actor() self.build_movie() self.build_rel() def build_movie(self): stmt_movie = select(mysql_model.Movie) for actor_movie in self.session.scalars(stmt_movie): neo4j_movie = covertor_movie(actor_movie) self.repo.create(neo4j_movie) def build_actor(self): stmt_actor = select(mysql_model.Actor) for actor_mysql in self.session.scalars(stmt_actor): neo4j_actor = covertor_actor(actor_mysql) self.repo.create(neo4j_actor) def build_rel(self): stmt = select(mysql_model.ActorToMovie) for element in self.session.scalars(stmt): actor = self.repo.match(neo4j_model.Actor).where(id=element.actor_id).first() movie = self.repo.match(neo4j_model.Movie).where(id=element.movie_id).first() relation_ship = Relationship(actor, \u0026#34;ACTED_IN\u0026#34;, movie) self.repo.create(relation_ship) if __name__ == \u0026#39;__main__\u0026#39;: kg = ActorMovieKG() kg.build_graph() print(\u0026#34;建立知识图谱完成\u0026#34;) 知识图谱使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from py2neo.ogm import Repository from custom_model.neo4j_model import Actor class KGClient: def __init__(self): self.repo = Repository(\u0026#34;bolt://neo4j@127.0.0.1:7687\u0026#34;, password=\u0026#34;123456\u0026#34;) def build_graph(self): cypher = \u0026#34;\u0026#34;\u0026#34;CALL gds.graph.project( \u0026#39;ActorMovieGraph\u0026#39;, [\u0026#39;Actor\u0026#39;, \u0026#39;Movie\u0026#39;], \u0026#39;ACTED_IN\u0026#39; ); \u0026#34;\u0026#34;\u0026#34; self.repo.graph.run(cypher) def query_similarity(self, name: str): \u0026#34;\u0026#34;\u0026#34;找出演员中的紧密程度\u0026#34;\u0026#34;\u0026#34; cypher = f\u0026#34;\u0026#34;\u0026#34;CALL gds.nodeSimilarity.stream(\u0026#39;ActorMovieGraph\u0026#39;) YIELD node1, node2, similarity WITH gds.util.asNode(node1) AS actor1, gds.util.asNode(node2) AS actor2, similarity WHERE actor1.actor_chName = \u0026#39;{name}\u0026#39; RETURN actor1.actor_chName, actor2.actor_chName, similarity ORDER BY similarity DESCENDING \u0026#34;\u0026#34;\u0026#34; result = self.repo.graph.run(cypher).data() print(result) def query_all_movies(self, name: str): actor = self.repo.match(Actor).where( actor_chName=name ).first() if actor is None: raise ValueError(\u0026#39;input error!\u0026#39;) for movie in actor.acted_in: print(movie.movie_chName) if __name__ == \u0026#39;__main__\u0026#39;: kg_client = KGClient() # kg_client.build_graph() # kg_client.query_all_movies(\u0026#34;张家辉\u0026#34;) kg_client.query_similarity(\u0026#34;鲍方\u0026#34;) 结果展示 图谱展示： 查询和鲍方合作的明星，目前actor_to_movie表中的数据太少了，建立的联系不多，只查询出来2个 代码地址 ActorMovieKG\n参考资料 从零开始构建影视类知识图谱（一）半结构化数据的获取 - 知乎 (zhihu.com)\n刘焕勇老师的github项目QABasedOnMedicaKnowledgeGraph\n","date":"2023-07-07T23:49:21+08:00","image":"https://ichigo-xin.github.io/imgs/neo4j_kg1.png","permalink":"https://ichigo-xin.github.io/p/neo4j%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E4%BD%BF%E7%94%A8neo4j%E6%9E%84%E5%BB%BA%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/","title":"Neo4j和知识图谱：使用Neo4j构建知识图谱"},{"content":"在本篇文章中，我会对Neo4j Graph Data Science进行介绍，并且使用其中的算法做相似分析，这样可以让你更快的了解Neo4j Graph Data Science，并将其应用到实践中。\n本文是全系列中的第2/3篇\nNeo4j和知识图谱：Neo4j安装和使用\nNeo4j和知识图谱：Neo4j内置算法库的安装和使用\nNeo4j和知识图谱：使用Neo4j构建知识图谱\nNeo4j Graph Data Science介绍 The Neo4j Graph Data Science (GDS) library provides efficiently implemented, parallel versions of common graph algorithms, exposed as Cypher procedures. Additionally, GDS includes machine learning pipelines to train predictive supervised models to solve graph problems, such as predicting missing relationships.\n这是官网的介绍，接下来我也将称Neo4j Graph Data Science 为GDS。GDS提供了图算法，同时也可以用于机器学习。\n根据处理问题类型，算法分为以下几类：\n中心性\n社区\n相似度\n路径寻找\n节点嵌入\n拓扑链路预测\n这篇文章后面会介绍相似分析的案例。\nGDS安装 下载GDS包，下载地址\n1 2 3 4 5 6 7 8 9 10 将neo4j-graph-data-science-2.4.0.jar放入plugins目录下修改conf文件 vim conf/neo4j.conf dbms.security.procedures.unrestricted=my.extensions.example,my.procedures.*,gds.* dbms.security.procedures.allowlist=apoc.coll.*,apoc.load.*,gds.* 重启neo4j，bin/neo4j restart 在web控制台中输入RETURN gds.version();就可以查询是否安装成功 相似分析 相似分析主要是通过分析两个节点的共有相邻的节点来进行相似分析的。\n对于两个集合A和B，Jaccard相似度计算为：\n重叠系数使用下面的公式:\n对于数据库中的两个节点n和m，A就是和n所有相邻的节点的集合，同样的B是m相邻节点的集合\nNeo4j中的相似算法提供了许多有用的功能，适用于各种场景。以下是一些常见的使用场景：\n推荐系统：通过计算节点之间的相似性，可以构建基于内容或基于协同过滤的推荐系统。相似算法（如相似度计算或最短路径）可以帮助发现相似的用户、产品或兴趣，并向用户提供个性化的推荐。\n社交网络分析：相似算法可以帮助发现社交网络中的相似用户、群组或兴趣。例如，可以使用相似度算法（如Jaccard相似系数）来寻找在兴趣或活动上具有相似性的用户。\n产品推荐：相似算法可以帮助发现产品之间的相似性，从而实现商品推荐和交叉销售。通过计算产品之间的相似度，可以根据用户的购买历史或兴趣，向其推荐类似的产品。\n知识图谱分析：相似算法可以用于分析和比较知识图谱中的实体、关系或概念。通过计算实体之间的相似度，可以发现潜在的关联和模式，并进行语义推理。\n相似分析实战 数据准备 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 CREATE (alice:Person {name: \u0026#39;Alice\u0026#39;}), (bob:Person {name: \u0026#39;Bob\u0026#39;}), (carol:Person {name: \u0026#39;Carol\u0026#39;}), (dave:Person {name: \u0026#39;Dave\u0026#39;}), (eve:Person {name: \u0026#39;Eve\u0026#39;}), (guitar:Instrument {name: \u0026#39;Guitar\u0026#39;}), (synth:Instrument {name: \u0026#39;Synthesizer\u0026#39;}), (bongos:Instrument {name: \u0026#39;Bongos\u0026#39;}), (trumpet:Instrument {name: \u0026#39;Trumpet\u0026#39;}), (rice:Food1 {name: \u0026#39;Rice\u0026#39;}), (pizza:Food1 {name: \u0026#39;Pizza\u0026#39;}), (noodle:Food1 {name: \u0026#39;Noodle\u0026#39;}), (fish:Food1 {name: \u0026#39;Fish\u0026#39;}), (pig:Food1 {name: \u0026#39;Pig\u0026#39;}), (alice)-[:LIKES]-\u0026gt;(guitar), (alice)-[:LIKES]-\u0026gt;(synth), (alice)-[:LIKES]-\u0026gt;(bongos), (bob)-[:LIKES]-\u0026gt;(guitar), (bob)-[:LIKES]-\u0026gt;(synth), (carol)-[:LIKES]-\u0026gt;(bongos), (dave)-[:LIKES]-\u0026gt;(guitar), (dave)-[:LIKES {strength: 1.5}]-\u0026gt;(trumpet), (dave)-[:LIKES]-\u0026gt;(bongos); MATCH (alice:Person {name: \u0026#39;Alice\u0026#39;}), (rice:Food1 {name: \u0026#39;Rice\u0026#39;}) CREATE (alice)-[:EAT]-\u0026gt;(rice); MATCH (alice:Person {name: \u0026#39;Alice\u0026#39;}), (pizza:Food1 {name: \u0026#39;Pizza\u0026#39;}) CREATE (alice)-[:EAT]-\u0026gt;(pizza); MATCH (alice:Person {name: \u0026#39;Alice\u0026#39;}), (noodle:Food1 {name: \u0026#39;Noodle\u0026#39;}) CREATE (alice)-[:EAT]-\u0026gt;(noodle); MATCH (bob:Person {name: \u0026#39;Bob\u0026#39;}), (fish:Food1 {name: \u0026#39;Fish\u0026#39;}) CREATE (bob)-[:EAT]-\u0026gt;(fish); MATCH (bob:Person {name: \u0026#39;Bob\u0026#39;}), (pizza:Food1 {name: \u0026#39;Pizza\u0026#39;}) CREATE (bob)-[:EAT]-\u0026gt;(pizza); MATCH (bob:Person {name: \u0026#39;Bob\u0026#39;}), (noodle:Food1 {name: \u0026#39;Noodle\u0026#39;}) CREATE (bob)-[:EAT]-\u0026gt;(noodle); MATCH (carol:Person {name: \u0026#39;Carol\u0026#39;}), (fish:Food1 {name: \u0026#39;Fish\u0026#39;}) CREATE (carol)-[:EAT]-\u0026gt;(fish); MATCH (dave:Person {name: \u0026#39;Dave\u0026#39;}), (pizza:Food1 {name: \u0026#39;Pizza\u0026#39;}) CREATE (dave)-[:EAT]-\u0026gt;(pizza); 这样我们就建立了一个如下的关系图 建立投影 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 CALL gds.graph.project( \u0026#39;myGraph\u0026#39;, [\u0026#39;Person\u0026#39;, \u0026#39;Instrument\u0026#39;], { LIKES: { properties: { strength: { property: \u0026#39;strength\u0026#39;, defaultValue: 1.0 } } } } ); CALL gds.graph.project( \u0026#39;myGraph1\u0026#39;, [\u0026#39;Person\u0026#39;, \u0026#39;Instrument\u0026#39;, \u0026#39;Food1\u0026#39;], { EAT: { type: \u0026#39;EAT\u0026#39;, properties: { strength: { property: \u0026#39;strength\u0026#39;, defaultValue: 0.5 } } }, LIKES: { type: \u0026#39;LIKES\u0026#39;, properties: { strength: { property: \u0026#39;strength\u0026#39;, defaultValue: 1.0 } } } } ); 这样我们就建立了两个投影，graph中包含了Person和Instrument节点，graph1中包含了Person、Instrument和Food1节点\n计算相似度 1.计算所有节点的相似度\n1 2 3 4 CALL gds.nodeSimilarity.stream(\u0026#39;myGraph\u0026#39;) YIELD node1, node2, similarity RETURN gds.util.asNode(node1).name AS Person1, gds.util.asNode(node2).name AS Person2, similarity ORDER BY similarity DESCENDING, Person1, Person2 语法解析：\nCALL gds.nodeSimilarity.stream(\u0026lsquo;myGraph\u0026rsquo;) 在myGraph投影中使用nodeSimilarity相似分析算法 YIELD node1, node2, similarity 使用节点node1、node2和相似度similarity RETURN gds.util.asNode(node1).name AS Person1, gds.util.asNode(node2).name AS Person2, similarity 返回结果 ORDER BY similarity DESCENDING, Person1, Person2 排序方式 2.计算myGraph投影中与Alice的相似度\n1 2 3 4 5 6 CALL gds.nodeSimilarity.stream(\u0026#39;myGraph\u0026#39;) YIELD node1, node2, similarity WITH gds.util.asNode(node1) AS person1, gds.util.asNode(node2) AS person2, similarity WHERE person1.name = \u0026#39;Alice\u0026#39; RETURN person1.name AS Person1, person2.name AS Person2, similarity ORDER BY similarity DESCENDING 3.计算myGraph1投影中与Alice的相似度\n1 2 3 4 5 6 CALL gds.nodeSimilarity.stream(\u0026#39;myGraph1\u0026#39;) YIELD node1, node2, similarity WITH gds.util.asNode(node1) AS person1, gds.util.asNode(node2) AS person2, similarity WHERE person1.name = \u0026#39;Alice\u0026#39; RETURN person1.name AS Person1, person2.name AS Person2, similarity ORDER BY similarity DESCENDING 4.添加关系之后再计算与Alice的相似度 需要删除投影之后再重新建立（投影在建立的时候就已经固定了，更新了关系之后需要更新投影）\n1 2 3 4 5 6 7 8 MATCH (dave:Person {name: \u0026#39;Dave\u0026#39;}), (rice:Food1 {name: \u0026#39;Rice\u0026#39;}), (pizza:Food1 {name: \u0026#39;Pizza\u0026#39;}) ,(synthesizer:Instrument {name:\u0026#34;Synthesizer\u0026#34;}) CREATE (dave)-[:LIKES]-\u0026gt;(synthesizer) (dave)-[:EAT]-\u0026gt;(rice), (dave)-[:EAT]-\u0026gt;(pizza); CALL gds.graph.drop(\u0026#39;myGraph1\u0026#39;) 执行结果如下： 现在是alice最相似的是bob了\n","date":"2023-07-03T20:52:02+08:00","image":"https://ichigo-xin.github.io/imgs/DM_20230703230529_001.png","permalink":"https://ichigo-xin.github.io/p/neo4j%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1neo4j%E5%86%85%E7%BD%AE%E7%AE%97%E6%B3%95%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/","title":"Neo4j和知识图谱：Neo4j内置算法库的安装和使用"},{"content":"这篇文章介绍一个小小的检测脚本，用来检测写的博客有没有个人信息，以及如何在电脑上快速配置命令方便使用。\n需要电脑上安装了python3，并且配置了环境变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 文件名 check_personnal_info.py import sys def detect_personal_info(file_path): target_strings = [\u0026#39;root\u0026#39;, \u0026#39;729\u0026#39;] # 替换为你要检测的个人信息字符串列表 with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as file: lines = file.readlines() for i, line in enumerate(lines): for target_string in target_strings: if target_string.lower() in line.lower(): print(f\u0026#34;个人信息字符串 \u0026#39;{target_string}\u0026#39; 出现在第 {i+1} 行：\\n{line}\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: if len(sys.argv) \u0026lt; 2: print(\u0026#34;请提供文件名作为参数\u0026#34;) else: file_path = sys.argv[1] detect_personal_info(file_path) 然后在e盘新建一个文件夹 E:\\PythonScript，里面用于存放bat文件和py脚本，将E:\\PythonScript添加到环境变量里面（在系统高级设置里面，设置环境变量，将E:\\PythonScript添加到path里面） 在PythonScript文件家里面新建check_personnal_info.py文件，将代码copy进去 在该文件夹里面新建check.bat文件,文件内容如下\n1 @python.exe E:\\PythonScript\\check_personnal_info.py %* 在对应博客目录执行 check + 文件名 即可，如 check check.md ","date":"2023-07-01T14:38:30+08:00","permalink":"https://ichigo-xin.github.io/p/%E6%A3%80%E6%B5%8B%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E8%84%9A%E6%9C%AC%E5%92%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"检测博客中的个人信息脚本和环境配置"},{"content":"在本篇文章中，我会对Neo4j图数据库、查询语句Cypher进行介绍，这样可以让你更容易掌握这门技术。其中主要包括Neo4j的安装配置，查询语句Cypher使用。\n本文是全系列中的第1/3篇\nNeo4j和知识图谱：Neo4j安装和使用\nNeo4j和知识图谱：Neo4j内置算法库的安装和使用\nNeo4j和知识图谱：使用Neo4j构建知识图谱\nNeo4j和知识图谱：项目中使用py2neo的ogm框架构建知识图谱\nNeo4j介绍 Neo4j是一种广泛使用的图形数据库管理系统，专注于存储和处理具有复杂关系的数据。它使用图形模型来表示数据，其中节点表示实体，边表示实体之间的关系。Neo4j提供了一种高效灵活的方式来处理和查询这些图形数据。\nNeo4j的使用场景非常丰富，适用于多个领域和行业。以下是一些常见的使用场景：\n社交网络分析：Neo4j可以存储和分析社交网络中的用户关系、兴趣和活动。它能够高效地执行复杂的关系查询，例如查找朋友的朋友、查找共同兴趣的人等。 推荐系统：Neo4j可以帮助构建个性化的推荐系统。通过建模用户、产品和其它相关属性之间的关系，Neo4j能够快速查询和发现潜在的兴趣和推荐。 知识图谱和语义网络：Neo4j能够存储和查询知识图谱，这是一种表示实体之间关系和属性的结构化数据模型。知识图谱广泛应用于搜索引擎、智能助手和推荐系统等领域。 这些场景用关系型数据库实现非常困难，这就是图数据库发挥作用的地方。\nNeo4j安装 Neo4j有社区版和企业版。这里我们选择社区版，同时Neo4j使用Java进行开发的，因此和JDK版本有着对应关系，4.x的版本选择jdk11，因为后续会安装算法库，再加上项目开发的需求就选择了neo4j-community-4.4.22-unix的版本。\nNeo4j version Neo4j Graph Data Science 5.9 2.4, 2.3.9 or later 5.8 2.4, 2.3.6 or later 5.7 2.4, 2.3.3 or later 5.6 2.4, 2.3.2 or later 5.5 2.4, 2.3.1 or later 5.4 2.4, 2.3 5.3 2.4, 2.3 5.2 2.4, 2.3 5.1 2.4, 2.3 4.4.9 or later 2.4, 2.3 具体版本要求官网地址\n下载地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 安装步骤 安装前需要安装jdk11 1.解压安装包 tar -xf neo4j-community-4.4.22-unix.tar.gz 2.配置neo4j cd neo4j-community-4.4.22/ vim conf/neo4j.conf dbms.memory.heap.initial_size=4g #根据服务器的内存进行修改 dbms.memory.heap.max_size=4g #根据服务器的内存进行修改 dbms.default_listen_address=0.0.0.0 #设置可以远程访问 dbms.connector.http.listen_address=:7474 3.启动 bin/neo4j start 看下服务有没有启动 ps -ef | grep neo 4.打开浏览器，并访问 http://ip:7474/ ，这将打开Neo4j的Web控制台 用户名和密码 neo4j/neo4j Cypher的使用 用cypher查询neo4j就相当于用sql查询mysql\n创建节点 创建单个节点\n1 create (n:Person {name:\u0026#34;孙悟空\u0026#34;}) 创建多个节点\n1 CREATE (n:Person {name: \u0026#34;唐三藏\u0026#34;}), (m:Person {name: \u0026#34;猪八戒\u0026#34;, weapon: \u0026#34;九齿钉耙\u0026#34;}) 如果没有定义model的话，对于一个节点是可以随意配置属性的，上面的猪八戒中就多了个武器的属性\n创建关系 语法: ()代表实体，-[]-\u0026gt;代表关系\n1 create ()-[]-\u0026gt;() 创建已有节点的关系\n1 2 3 MATCH (n:Person ) match (n:Person{name:\u0026#34;孙悟空\u0026#34;}), (m:Person{name:\u0026#34;猪八戒\u0026#34;}) create (n)-[r:shidi{name:\u0026#34;师弟\u0026#34;}]-\u0026gt;(m) 创建节点和关系\n删除节点 1 2 match (n:Person {name:\u0026#39;唐三藏\u0026#39;}) delete n 删除关系 1 2 match (n:Person {name:\u0026#34;李靖\u0026#34;})-[r:child]-\u0026gt;(m:Person {name:\u0026#39;哪吒\u0026#39;}) delete r 修改属性值 1 2 match (n:Person {name:\u0026#34;孙悟空\u0026#34;}) set n.weapon = \u0026#34;如意金箍棒\u0026#34; 查询 就是match，然后接个return\n1 2 3 4 5 6 7 match (n:Person {name:\u0026#34;孙悟空\u0026#34;}) return n 使用where进行过滤 match (n:Person ) where n.name = \u0026#34;猪八戒\u0026#34; return n 使用limit进行限制 match (n:Person ) return n limit 2 ","date":"2023-06-28T21:00:04+08:00","permalink":"https://ichigo-xin.github.io/p/neo4j%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1neo4j%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/","title":"Neo4j和知识图谱：Neo4j安装和使用"}]
>>>>>>> 4bf6685c44f0c2945e20d7475845e4e0c06647e4
