[{"content":"在本篇文章中，我会对Neo4j Graph Data Science进行介绍，并且使用其中的算法做相似分析，这样可以让你更快的了解Neo4j Graph Data Science，并将其应用到实践中。\n本文是全系列中的第2/4篇\nNeo4j和知识图谱：Neo4j安装和使用\nNeo4j和知识图谱：Neo4j内置算法库的安装和使用\nNeo4j和知识图谱：使用Neo4j构建知识图谱\nNeo4j和知识图谱：项目中使用py2neo的ogm框架构建知识图谱\nNeo4j Graph Data Science介绍 The Neo4j Graph Data Science (GDS) library provides efficiently implemented, parallel versions of common graph algorithms, exposed as Cypher procedures. Additionally, GDS includes machine learning pipelines to train predictive supervised models to solve graph problems, such as predicting missing relationships.\n这是官网的介绍，接下来我也将称Neo4j Graph Data Science 为GDS。GDS提供了图算法，同时也可以用于机器学习。\n根据处理问题类型，算法分为以下几类：\n中心性\n社区\n相似度\n路径寻找\n节点嵌入\n拓扑链路预测\n这篇文章后面会介绍相似分析的案例。\nGDS安装 下载GDS包，下载地址\n1 2 3 4 5 6 7 8 9 10 将neo4j-graph-data-science-2.4.0.jar放入plugins目录下修改conf文件 vim conf/neo4j.conf dbms.security.procedures.unrestricted=my.extensions.example,my.procedures.*,gds.* dbms.security.procedures.allowlist=apoc.coll.*,apoc.load.*,gds.* 重启neo4j，bin/neo4j restart 在web控制台中输入RETURN gds.version();就可以查询是否安装成功 相似分析 相似分析主要是通过分析两个节点的共有相邻的节点来进行相似分析的。\n对于两个集合A和B，Jaccard相似度计算为：\n重叠系数使用下面的公式:\n对于数据库中的两个节点n和m，A就是和n所有相邻的节点的集合，同样的B是m相邻节点的集合\nNeo4j中的相似算法提供了许多有用的功能，适用于各种场景。以下是一些常见的使用场景：\n推荐系统：通过计算节点之间的相似性，可以构建基于内容或基于协同过滤的推荐系统。相似算法（如相似度计算或最短路径）可以帮助发现相似的用户、产品或兴趣，并向用户提供个性化的推荐。\n社交网络分析：相似算法可以帮助发现社交网络中的相似用户、群组或兴趣。例如，可以使用相似度算法（如Jaccard相似系数）来寻找在兴趣或活动上具有相似性的用户。\n产品推荐：相似算法可以帮助发现产品之间的相似性，从而实现商品推荐和交叉销售。通过计算产品之间的相似度，可以根据用户的购买历史或兴趣，向其推荐类似的产品。\n知识图谱分析：相似算法可以用于分析和比较知识图谱中的实体、关系或概念。通过计算实体之间的相似度，可以发现潜在的关联和模式，并进行语义推理。\n相似分析实战 数据准备 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 CREATE (alice:Person {name: \u0026#39;Alice\u0026#39;}), (bob:Person {name: \u0026#39;Bob\u0026#39;}), (carol:Person {name: \u0026#39;Carol\u0026#39;}), (dave:Person {name: \u0026#39;Dave\u0026#39;}), (eve:Person {name: \u0026#39;Eve\u0026#39;}), (guitar:Instrument {name: \u0026#39;Guitar\u0026#39;}), (synth:Instrument {name: \u0026#39;Synthesizer\u0026#39;}), (bongos:Instrument {name: \u0026#39;Bongos\u0026#39;}), (trumpet:Instrument {name: \u0026#39;Trumpet\u0026#39;}), (rice:Food1 {name: \u0026#39;Rice\u0026#39;}), (pizza:Food1 {name: \u0026#39;Pizza\u0026#39;}), (noodle:Food1 {name: \u0026#39;Noodle\u0026#39;}), (fish:Food1 {name: \u0026#39;Fish\u0026#39;}), (pig:Food1 {name: \u0026#39;Pig\u0026#39;}), (alice)-[:LIKES]-\u0026gt;(guitar), (alice)-[:LIKES]-\u0026gt;(synth), (alice)-[:LIKES]-\u0026gt;(bongos), (bob)-[:LIKES]-\u0026gt;(guitar), (bob)-[:LIKES]-\u0026gt;(synth), (carol)-[:LIKES]-\u0026gt;(bongos), (dave)-[:LIKES]-\u0026gt;(guitar), (dave)-[:LIKES {strength: 1.5}]-\u0026gt;(trumpet), (dave)-[:LIKES]-\u0026gt;(bongos); MATCH (alice:Person {name: \u0026#39;Alice\u0026#39;}), (rice:Food1 {name: \u0026#39;Rice\u0026#39;}) CREATE (alice)-[:EAT]-\u0026gt;(rice); MATCH (alice:Person {name: \u0026#39;Alice\u0026#39;}), (pizza:Food1 {name: \u0026#39;Pizza\u0026#39;}) CREATE (alice)-[:EAT]-\u0026gt;(pizza); MATCH (alice:Person {name: \u0026#39;Alice\u0026#39;}), (noodle:Food1 {name: \u0026#39;Noodle\u0026#39;}) CREATE (alice)-[:EAT]-\u0026gt;(noodle); MATCH (bob:Person {name: \u0026#39;Bob\u0026#39;}), (fish:Food1 {name: \u0026#39;Fish\u0026#39;}) CREATE (bob)-[:EAT]-\u0026gt;(fish); MATCH (bob:Person {name: \u0026#39;Bob\u0026#39;}), (pizza:Food1 {name: \u0026#39;Pizza\u0026#39;}) CREATE (bob)-[:EAT]-\u0026gt;(pizza); MATCH (bob:Person {name: \u0026#39;Bob\u0026#39;}), (noodle:Food1 {name: \u0026#39;Noodle\u0026#39;}) CREATE (bob)-[:EAT]-\u0026gt;(noodle); MATCH (carol:Person {name: \u0026#39;Carol\u0026#39;}), (fish:Food1 {name: \u0026#39;Fish\u0026#39;}) CREATE (carol)-[:EAT]-\u0026gt;(fish); MATCH (dave:Person {name: \u0026#39;Dave\u0026#39;}), (pizza:Food1 {name: \u0026#39;Pizza\u0026#39;}) CREATE (dave)-[:EAT]-\u0026gt;(pizza); 这样我们就建立了一个如下的关系图 建立投影 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 CALL gds.graph.project( \u0026#39;myGraph\u0026#39;, [\u0026#39;Person\u0026#39;, \u0026#39;Instrument\u0026#39;], { LIKES: { properties: { strength: { property: \u0026#39;strength\u0026#39;, defaultValue: 1.0 } } } } ); CALL gds.graph.project( \u0026#39;myGraph1\u0026#39;, [\u0026#39;Person\u0026#39;, \u0026#39;Instrument\u0026#39;, \u0026#39;Food1\u0026#39;], { EAT: { type: \u0026#39;EAT\u0026#39;, properties: { strength: { property: \u0026#39;strength\u0026#39;, defaultValue: 0.5 } } }, LIKES: { type: \u0026#39;LIKES\u0026#39;, properties: { strength: { property: \u0026#39;strength\u0026#39;, defaultValue: 1.0 } } } } ); 这样我们就建立了两个投影，graph中包含了Person和Instrument节点，graph1中包含了Person、Instrument和Food1节点\n计算相似度 1.计算所有节点的相似度\n1 2 3 4 CALL gds.nodeSimilarity.stream(\u0026#39;myGraph\u0026#39;) YIELD node1, node2, similarity RETURN gds.util.asNode(node1).name AS Person1, gds.util.asNode(node2).name AS Person2, similarity ORDER BY similarity DESCENDING, Person1, Person2 语法解析：\nCALL gds.nodeSimilarity.stream(\u0026lsquo;myGraph\u0026rsquo;) 在myGraph投影中使用nodeSimilarity相似分析算法 YIELD node1, node2, similarity 使用节点node1、node2和相似度similarity RETURN gds.util.asNode(node1).name AS Person1, gds.util.asNode(node2).name AS Person2, similarity 返回结果 ORDER BY similarity DESCENDING, Person1, Person2 排序方式 2.计算myGraph投影中与Alice的相似度\n1 2 3 4 5 6 CALL gds.nodeSimilarity.stream(\u0026#39;myGraph\u0026#39;) YIELD node1, node2, similarity WITH gds.util.asNode(node1) AS person1, gds.util.asNode(node2) AS person2, similarity WHERE person1.name = \u0026#39;Alice\u0026#39; RETURN person1.name AS Person1, person2.name AS Person2, similarity ORDER BY similarity DESCENDING 3.计算myGraph1投影中与Alice的相似度\n1 2 3 4 5 6 CALL gds.nodeSimilarity.stream(\u0026#39;myGraph1\u0026#39;) YIELD node1, node2, similarity WITH gds.util.asNode(node1) AS person1, gds.util.asNode(node2) AS person2, similarity WHERE person1.name = \u0026#39;Alice\u0026#39; RETURN person1.name AS Person1, person2.name AS Person2, similarity ORDER BY similarity DESCENDING 4.添加关系之后再计算与Alice的相似度 需要删除投影之后再重新建立（投影在建立的时候就已经固定了，更新了关系之后需要更新投影）\n1 2 3 4 5 6 7 8 MATCH (dave:Person {name: \u0026#39;Dave\u0026#39;}), (rice:Food1 {name: \u0026#39;Rice\u0026#39;}), (pizza:Food1 {name: \u0026#39;Pizza\u0026#39;}) ,(synthesizer:Instrument {name:\u0026#34;Synthesizer\u0026#34;}) CREATE (dave)-[:LIKES]-\u0026gt;(synthesizer) (dave)-[:EAT]-\u0026gt;(rice), (dave)-[:EAT]-\u0026gt;(pizza); CALL gds.graph.drop(\u0026#39;myGraph1\u0026#39;) 执行结果如下： 现在是alice最相似的是bob了\n","date":"2023-07-03T20:52:02+08:00","image":"https://ichigo-xin.github.io/imgs/DM_20230703230529_001.png","permalink":"https://ichigo-xin.github.io/p/neo4j%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1neo4j%E5%86%85%E7%BD%AE%E7%AE%97%E6%B3%95%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/","title":"Neo4j和知识图谱：Neo4j内置算法库的安装和使用"},{"content":"这篇文章介绍一个小小的检测脚本，用来检测写的博客有没有个人信息，以及如何在电脑上快速配置命令方便使用。\n需要电脑上安装了python3，并且配置了环境变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 文件名 check_personnal_info.py import sys def detect_personal_info(file_path): target_strings = [\u0026#39;root\u0026#39;, \u0026#39;729\u0026#39;] # 替换为你要检测的个人信息字符串列表 with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as file: lines = file.readlines() for i, line in enumerate(lines): for target_string in target_strings: if target_string.lower() in line.lower(): print(f\u0026#34;个人信息字符串 \u0026#39;{target_string}\u0026#39; 出现在第 {i+1} 行：\\n{line}\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: if len(sys.argv) \u0026lt; 2: print(\u0026#34;请提供文件名作为参数\u0026#34;) else: file_path = sys.argv[1] detect_personal_info(file_path) 然后在e盘新建一个文件夹 E:\\PythonScript，里面用于存放bat文件和py脚本，将E:\\PythonScript添加到环境变量里面（在系统高级设置里面，设置环境变量，将E:\\PythonScript添加到path里面） 在PythonScript文件家里面新建check_personnal_info.py文件，将代码copy进去 在该文件夹里面新建check.bat文件,文件内容如下\n1 @python.exe E:\\PythonScript\\check_personnal_info.py %* 在对应博客目录执行 check + 文件名 即可，如 check check.md ","date":"2023-07-01T14:38:30+08:00","permalink":"https://ichigo-xin.github.io/p/%E6%A3%80%E6%B5%8B%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E8%84%9A%E6%9C%AC%E5%92%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"检测博客中的个人信息脚本和环境配置"},{"content":"在本篇文章中，我会对Neo4j图数据库、查询语句Cypher进行介绍，这样可以让你更容易掌握这门技术。其中主要包括Neo4j的安装配置，查询语句Cypher使用。\n本文是全系列中的第1/4篇\nNeo4j和知识图谱：Neo4j安装和使用\nNeo4j和知识图谱：Neo4j内置算法库的安装和使用\nNeo4j和知识图谱：使用Neo4j构建知识图谱\nNeo4j和知识图谱：项目中使用py2neo的ogm框架构建知识图谱\nNeo4j介绍 Neo4j是一种广泛使用的图形数据库管理系统，专注于存储和处理具有复杂关系的数据。它使用图形模型来表示数据，其中节点表示实体，边表示实体之间的关系。Neo4j提供了一种高效灵活的方式来处理和查询这些图形数据。\nNeo4j的使用场景非常丰富，适用于多个领域和行业。以下是一些常见的使用场景：\n社交网络分析：Neo4j可以存储和分析社交网络中的用户关系、兴趣和活动。它能够高效地执行复杂的关系查询，例如查找朋友的朋友、查找共同兴趣的人等。 推荐系统：Neo4j可以帮助构建个性化的推荐系统。通过建模用户、产品和其它相关属性之间的关系，Neo4j能够快速查询和发现潜在的兴趣和推荐。 知识图谱和语义网络：Neo4j能够存储和查询知识图谱，这是一种表示实体之间关系和属性的结构化数据模型。知识图谱广泛应用于搜索引擎、智能助手和推荐系统等领域。 这些场景用关系型数据库实现非常困难，这就是图数据库发挥作用的地方。\nNeo4j安装 Neo4j有社区版和企业版。这里我们选择社区版，同时Neo4j使用Java进行开发的，因此和JDK版本有着对应关系，4.x的版本选择jdk11，因为后续会安装算法库，再加上项目开发的需求就选择了neo4j-community-4.4.22-unix的版本。\nNeo4j version Neo4j Graph Data Science 5.9 2.4, 2.3.9 or later 5.8 2.4, 2.3.6 or later 5.7 2.4, 2.3.3 or later 5.6 2.4, 2.3.2 or later 5.5 2.4, 2.3.1 or later 5.4 2.4, 2.3 5.3 2.4, 2.3 5.2 2.4, 2.3 5.1 2.4, 2.3 4.4.9 or later 2.4, 2.3 具体版本要求官网地址\n下载地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 安装步骤 安装前需要安装jdk11 1.解压安装包 tar -xf neo4j-community-4.4.22-unix.tar.gz 2.配置neo4j cd neo4j-community-4.4.22/ vim conf/neo4j.conf dbms.memory.heap.initial_size=4g #根据服务器的内存进行修改 dbms.memory.heap.max_size=4g #根据服务器的内存进行修改 dbms.default_listen_address=0.0.0.0 #设置可以远程访问 dbms.connector.http.listen_address=:7474 3.启动 bin/neo4j start 看下服务有没有启动 ps -ef | grep neo 4.打开浏览器，并访问 http://ip:7474/ ，这将打开Neo4j的Web控制台 用户名和密码 neo4j/neo4j Cypher的使用 用cypher查询neo4j就相当于用sql查询mysql\n创建节点 创建单个节点\n1 create (n:Person {name:\u0026#34;孙悟空\u0026#34;}) 创建多个节点\n1 CREATE (n:Person {name: \u0026#34;唐三藏\u0026#34;}), (m:Person {name: \u0026#34;猪八戒\u0026#34;, weapon: \u0026#34;九齿钉耙\u0026#34;}) 如果没有定义model的话，对于一个节点是可以随意配置属性的，上面的猪八戒中就多了个武器的属性\n创建关系 语法: ()代表实体，-[]-\u0026gt;代表关系\n1 create ()-[]-\u0026gt;() 创建已有节点的关系\n1 2 3 MATCH (n:Person ) match (n:Person{name:\u0026#34;孙悟空\u0026#34;}), (m:Person{name:\u0026#34;猪八戒\u0026#34;}) create (n)-[r:shidi{name:\u0026#34;师弟\u0026#34;}]-\u0026gt;(m) 创建节点和关系\n删除节点 1 2 match (n:Person {name:\u0026#39;唐三藏\u0026#39;}) delete n 删除关系 1 2 match (n:Person {name:\u0026#34;李靖\u0026#34;})-[r:child]-\u0026gt;(m:Person {name:\u0026#39;哪吒\u0026#39;}) delete r 修改属性值 1 2 match (n:Person {name:\u0026#34;孙悟空\u0026#34;}) set n.weapon = \u0026#34;如意金箍棒\u0026#34; 查询 就是match，然后接个return\n1 2 3 4 5 6 7 match (n:Person {name:\u0026#34;孙悟空\u0026#34;}) return n 使用where进行过滤 match (n:Person ) where n.name = \u0026#34;猪八戒\u0026#34; return n 使用limit进行限制 match (n:Person ) return n limit 2 ","date":"2023-06-28T21:00:04+08:00","permalink":"https://ichigo-xin.github.io/p/neo4j%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1neo4j%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/","title":"Neo4j和知识图谱：Neo4j安装和使用"}]